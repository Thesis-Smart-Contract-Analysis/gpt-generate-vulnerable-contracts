{
  "id": "chatcmpl-9ZLYFuZmemsIsvb3sLw72FCJiyNPO",
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "message": {
        "content": "# Smart Contract\n\n```solidity\npragma solidity ^0.4.24;\n\ncontract HashForEther {\n\n  function withdrawWinnings() {\n    // Winner if the last 8 hex characters of the address are 0. \n    require(uint32(msg.sender) == 0);\n    _sendWinnings();\n  }\n  \n  function _sendWinnings() { // line 10\n    msg.sender.transfer(this.balance);\n  }\n     \n}\n```\n\nThe vulnerability in the above smart contract lies in the `_sendWinnings` function. This function is intended to be a private helper function to send winnings to the winner. However, it is not explicitly marked as `internal` or `private`, making it accessible to anyone. This means that any user can directly call `_sendWinnings` to transfer all the contract's balance to their address, bypassing the intended logic in `withdrawWinnings`.\n\n# Remediations\n\n1. **Set Explicit Visibility for Functions**: Ensure that all functions in the smart contract have an explicit visibility specifier. For the `_sendWinnings` function, it should be marked as `internal` to prevent external access, ensuring that it can only be called by other functions within the contract.\n\n   ```solidity\n   function _sendWinnings() internal {\n       msg.sender.transfer(this.balance);\n   }\n   ```\n\n2. **Use Modifiers for Access Control**: Implement custom modifiers to control the access to sensitive functions. For example, you could create a modifier that checks whether the caller is the intended recipient of the winnings before allowing the execution of `_sendWinnings`.\n\n   ```solidity\n   modifier onlyWinner() {\n       require(uint32(msg.sender) == 0, \"Not the winner\");\n       _;\n   }\n\n   function _sendWinnings() internal onlyWinner {\n       msg.sender.transfer(this.balance);\n   }\n   ```\n\nBy applying these remediations, the smart contract will be more secure against unauthorized access and manipulation, ensuring that only eligible parties can execute certain functions.",
        "role": "assistant",
        "function_call": null,
        "tool_calls": null
      }
    }
  ],
  "created": 1718211351,
  "model": "gpt-4-turbo-2024-04-09",
  "object": "chat.completion",
  "system_fingerprint": "fp_31a6c0accf",
  "usage": {
    "completion_tokens": 417,
    "prompt_tokens": 35693,
    "total_tokens": 36110
  },
  "vuln_id": "immutable-bugs",
  "kb": "# Function or State Variable Default Visibility\n\n## Mô tả\n\nTrạng thái hiển thị (visibility) mặc định của các hàm là `public`. Việc không khai báo trạng thái hiển thị một cách tường minh có thể gây ra các hành vi không mong muốn trong smart contract. Ví dụ, các hàm vốn chỉ được dùng trong nội bộ bên trong smart contract có thể bị gọi sử dụng một cách công khai bởi bất kỳ ai.\n\n```solidity\n/*\n * @source: https://github.com/sigp/solidity-security-blog#visibility\n * @author: SigmaPrime \n * Modified by Gerhard Wagner\n */\n\npragma solidity ^0.4.24;\n\ncontract HashForEther {\n\n  function withdrawWinnings() {\n    // Winner if the last 8 hex characters of the address are 0. \n    require(uint32(msg.sender) == 0);\n    _sendWinnings();\n  }\n  \n  function _sendWinnings() {\n    msg.sender.transfer(this.balance);\n  }\n     \n}\n```\n\nTrong ví dụ trên, bất kỳ ai cũng có thể gọi hàm `_sendWinnings` để rút ETH từ hợp đồng thông minh mà không cần phải tạo ra một địa chỉ có 8 ký tự cuối là `0`.\n\nĐối với các biến trạng thái, mặc dù trạng thái hiển thị mặc định của chúng là `internal`, việc khai báo trạng thái hiển thị một cách tường minh có thể giúp tránh được những nhầm lẫn về quyền truy cập.\n\n## Cách khắc phục\n\nKể từ phiên bản 0.5.0 @solidity-v0.5.0-breaking-changes, việc khai báo tường minh trạng thái hiển thị cho hàm là bắt buộc nên lỗ hổng này chỉ tồn tại ở các phiên bản trước đó của Solidity.\n\nMặc dù vậy, lập trình viên cũng nên xem xét cẩn thận việc sử dụng trạng thái hiển thị của từng hàm. Đặc biệt là những hàm có trạng thái hiển thị là `public` hoặc `external`.\n\nĐối với ví dụ của smart contract `HashForEther` ở trên, có thể thêm vào các visibility như sau:\n\n```solidity\n/*\n * @source: https://github.com/sigp/solidity-security-blog#visibility\n * @author: SigmaPrime\n * Modified by Gerhard Wagner\n */\n\npragma solidity ^0.4.24;\n\ncontract HashForEther {\n  \n  function withdrawWinnings() public {\n    // Winner if the last 8 hex characters of the address are 0.\n    require(uint32(msg.sender) == 0);\n    _sendWinnings();\n  }\n  \n  function _sendWinnings() internal {\n     msg.sender.transfer(this.balance);\n  }\n\n}\n```\n# Integer Overflow/Underflow <integer-overflow-underflow>\n\n## Mô tả\n\nCác kiểu dữ liệu lưu trữ số nguyên (bao gồm có dấu và không dấu) ở trong Solidity có kích thước là các lũy thừa cơ số 2 từ 8 đến 256. Khi thực hiện tính toán, dữ liệu có thể mang giá trị vượt ra ngoài phạm vi lưu trữ của kiểu dữ liệu. Vấn đề này được gọi là tràn số (overflow/underflow).\n\nTrong ví dụ dưới, nếu ta gọi hàm `run` với `input` là `2` thì giá trị của biến `count` sẽ là $1 -2 = -1 = 2^{256} - 1$ (kiểu `uint` thực chất là `uint256`).\n\n```solidity\n//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.4.19;\n\ncontract IntegerOverflowMinimal {\n  \n    uint public count = 1;\n\n    function run(uint256 input) public {\n        count -= input;\n    }\n    \n}\n```\n\n## Cách khắc phục\n\nCẩn thận khi thực hiện các tính toán trên số nguyên bằng cách so sánh các toán hạng trước khi thực hiện toán tử.\n\nSử dụng các thư viện chẳng hạn như SafeMath của OpenZeppelin @openzeppelin-math. Về bản chất, thư viện này sử dụng các câu lệnh `assert` hoặc `require` để đảm bảo các thao tác tính toán sẽ không gây ra tràn số.\n\nNgoài ra, kể từ phiên bản 0.8.0 @solidity-v0.8.0-breaking-changes của Solidity, lỗi tràn số được tự động phát hiện và giao dịch sẽ được hoàn trả trước khi thao tác tính toán được thực thi.\n\n\n\n# Outdated Compiler Version\n\n## Mô tả\n\nSử dụng một phiên bản trình biên dịch đã cũ có thể gây ra các vấn đề, đặc biệt là khi phiên bản đó có các lỗi và sự cố đã được tiết lộ công khai.\n\n## Cách khắc phục\n\nSử dụng phiên bản trình biên dịch của Solidity gần đây nhất.\n# Floating Compiler Version\n\n## Mô tả\n\nMột contract có thể được biên dịch bởi nhiều phiên bản của trình biên dịch khác nhau. \n\nVí dụ:\n\n```solidity\npragma solidity >=0.4.0 < 0.6.0;\npragma solidity >=0.4.0<0.6.0;\npragma solidity >=0.4.14 <0.6.0;\npragma solidity >0.4.13 <0.6.0;\npragma solidity 0.4.24 - 0.5.2;\npragma solidity >=0.4.24 <=0.5.3 ~0.4.20;\npragma solidity <0.4.26;\npragma solidity ~0.4.20;\npragma solidity ^0.4.14;\npragma solidity 0.4.*;\npragma solidity 0.*;\npragma solidity *;\npragma solidity 0.4;\npragma solidity 0;\n\ncontract SemVerFloatingPragma { }\n```\n\nTrong ví dụ trên, smart contract khai báo rất nhiều phiên bản của trình biên dịch theo kiểu SemVer (Semantic Versoning). Điều này có thể dẫn đến việc phiên bản được sử dụng lúc kiểm thử và lúc triển khai smart contract khác nhau. Nếu smart contract được triển khai bởi một phiên bản của trình biên dịch có chứa lỗi thì có thể làm ảnh hưởng đến tính đúng đắn của nó.\n\n## Cách khắc phục\n\nCần phải cố định phiên bản của trình biên dịch được sử dụng cho smart contract, ví dụ:\n\n```solidity\npragma solidity 0.4.25;\n// or\npragma solidity =0.4.25;\n\ncontract SemVerFloatingPragmaFixed { }\n```\n# Unchecked Return Value\n\n## Mô tả\n\nMột smart contract có thể giao tiếp với smart contract khác thông qua các cách sau:\n- Sử dụng các hàm ở mức thấp (opcode) chẳng hạn như `call`, `delegatecall` và `staticcall` để gọi hàm hoặc gửi ETH.\n- Sử dụng hàm `send` để gửi ETH.\n\nNếu có ngoại lệ xảy ra trong smart contract khác thì các hàm trên sẽ trả về giá trị luận lý cho biết thao tác không được thực hiện thành công thay vì lan truyền ngoại lệ. Nếu không kiểm tra giá trị luận lý này thì có thể làm ảnh hưởng đến kết quả thực thi của smart contract.\n\nVí dụ bên dưới dùng hàm `call` để gọi hàm `foo` của smart contract có địa chỉ là `_addr` với hai đối số lần lượt là `\"call foo\"` và `123`:\n\n```solidity\ncontract UsingCall {\n  \n  function invokeFunction(address payable _addr) public payable {\n  \t(bool success, bytes memory data) = _addr.call{\n    \tvalue: msg.value,\n    \tgas: 5000\n    }(abi.encodeWithSignature(\"foo(string,uint256)\", \"call foo\", 123));\n  }\n  \n}\n```\n\nNếu hàm `foo` xảy ra ngoại lệ, biến `success` sẽ có giá trị là `false` cho biết việc gọi hàm thất bại. Tuy nhiên, việc xảy ra ngoại lệ trong một smart contract khác không làm dừng quá trình thực thi của contract `UsingCall` cũng như là không hủy bỏ các sự thay đổi lên các biến trạng thái.\n\nTrong trường hợp sử dụng hàm `send`, ngoại lệ có thể xảy ra trong (các) hàm fallback của smart contract nhận ETH một cách tình cờ hoặc có chủ đích. \n\n## Cách khắc phục\n\nLuôn kiểm tra giá trị của biến luận lý được trả về từ các hàm dùng để giao tiếp với smart contract khác mà không lan truyền ngoại lệ.\n\nVí dụ:\n\n```solidity\npragma solidity 0.4.25;\n\ncontract ReturnValue {\n  \n  function callchecked(address callee) public {\n    require(callee.call());\n  }\n\n  function callnotchecked(address callee) public {\n    callee.call();\n  }\n  \n}\n```\n\n\n# Access Control Management\n\n## Mô tả\n\nViệc không kiểm soát quyền truy cập của hàm có thể khiến cho bất kỳ ai không có quyền cũng có thể thực thi hàm, đặc biệt là các hàm rút ETH hoặc gọi các hàm nguy hiểm chẳng hạn như `selfdestruct` #footnote[`selfdestruct` là một hàm dùng để xóa bytecode của smart contract ở trên blockchain và chuyển hết ETH còn lại trong smart contract đến địa chỉ được chỉ định.].\n\nVí dụ:\n\n```solidity\npragma solidity ^0.4.22;\n\ncontract SimpleEtherDrain {\n\n  function withdrawAllAnyone() {\n    msg.sender.transfer(this.balance);\n  }\n\n  function () public payable {\n  }\n  \n}\n```\n\nTrong ví dụ trên, hàm `withdrawAllAnyone` không áp dụng các biện pháp kiểm soát quyền truy cập nên bất kỳ ai cũng có thể gọi hàm và rút hết ETH từ smart contract.\n\nMột ví dụ khác:\n\n```solidity\npragma solidity ^0.4.22;\n\ncontract SimpleSuicide {\n\n  function sudicideAnyone() {\n    selfdestruct(msg.sender);\n  }\n  \n}\n```\n\nVới ví dụ này, do không kiểm soát quyền truy cập nên bất kỳ ai cũng có thể gọi hàm `sudicideAnyone` và rút hết ETH thông qua hàm `selfdestruct`.\n\n## Cách khắc phục\n\nCần giới hạn lại quyền truy cập của hàm cho một số địa chỉ nhất định. Có thể sử dụng các biện pháp kiểm soát quyền truy cập chẳng hạn như smart contract Ownable của OpenZeppelin @openzeppelin-ownership.\n\nVí dụ:\n\n```solidity\nimport \"./Ownable.sol\"\n\ncontract MyContract is Ownable {\n  INumberInterface numberContract;\n  \n  function setNumberContractAddress(address _address) external onlyOwner {\n    numberContract = INumberInterface(_address);\n  }\n  \n  function someFunction() public {\n    uint num = numberContract.getNum(msg.sender);\n  }\n}\n```\n\nTrong ví dụ trên, `onlyOwner` là một modifier giúp giới hạn quyền truy cập đến hàm. Cụ thể, nó ngăn không cho các địa chỉ không phải là chủ sở hữu smart contract thực thi hàm.\n\nCân nhắc không dùng hàm `selfdestruct` trong smart contract hoặc nếu có dùng thì sử dụng mô hình đa chữ ký để đảm bảo rằng có nhiều tổ chức đồng thuận với việc xóa bytecode của smart contract.\n\nNgoài ra, kể từ phiên bản 0.8.18 @eip-4758, Solidity không còn hỗ trợ hàm `selfdestruct`.\n\n\n# Re-entrancy <re-entrancy>\n\n## Mô tả <re-entrancy-description>\n\nLà một kiểu tấn công đệ quy tương hỗ xảy ra giữa smart contract của nạn nhân và smart contract của kẻ tấn công. Cụ thể hơn, kẻ tấn công sẽ liên tục gọi lại một hàm trong smart contract của nạn nhân trước khi lời gọi trước đó được thực thi xong.\n\nVí dụ bên dưới là phiên bản đơn giản của smart contract được dùng để vận hành DAO #footnote[DAO (Decentralized Autonomous Organizations) là một tập các smart contract hoạt động như một quỹ đầu tư tự động.]:\n\n```solidity\n/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * @author: Atzei N., Bartoletti M., Cimoli T\n * Modified by Josselin Feist\n */\npragma solidity 0.4.24;\n\ncontract SimpleDAO {\n  \n  mapping (address => uint) public credit;\n\n  function donate(address to) payable public{\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) public {\n    if (credit[msg.sender]>= amount) {\n      require(msg.sender.call.value(amount)());\n      credit[msg.sender]-=amount;\n    }\n  }  \n\n  function queryCredit(address to) view public returns(uint){\n    return credit[to];\n  }\n  \n}\n```\n\nTrong ví dụ trên, smart contract cho phép quyên góp một lượng `msg.value` wei đến cho địa chỉ `to` thông qua hàm `donate`. Để rút ETH, người dùng có thể gọi hàm `withdraw` và truyền vào tham số `amount` lượng ETH cần rút.\n\nKẻ tấn công có thể xây dựng một smart contract dùng để tấn công như sau:\n\n```solidity\npragma solidity 0.4.24;\n\ncontract Attacker {\n  \n  SimpleDAO public simpleDAO;\n\n  constructor(address _simpleDAOAddress) {\n    simpleDAO = SimpleDAO(_simpleDAOAddress);\n  }\n\n  function attack() {\n    simpleDAO.donate.value(1)(this);\n    simpleDAO.withdraw(1 ether);\n  }\n  \n  function() {\n    simpleDAO.withdraw(1 ether);\n  }\n  \n}\n```\n\nKhi kẻ tấn công gọi hàm `attack`, smart contract `Attacker` sẽ chuyển 1 ETH đến cho `SimpleDAO` thông qua hàm `donate` với đối số của `to` là địa chỉ của `Attacker`. Sau đó, hàm `attack` gọi đến hàm `withdraw` của `SimpleDAO` với đối số của `amount` là 1 ETH.\n\nLúc này, hàm `withdraw` của `SimpleDAO` sẽ gọi lại hàm fallback của `Attacker`. Tuy nhiên, hàm fallback của `Attacker` lại gọi đến hàm `withdraw` của `SimpleDAO`. Việc gọi hàm này ngăn cho biến trạng thái `credit[msg.sender]` bị giảm giá trị và dẫn đến điều kiện `if (credit[msg.sender]>= amount)` là luôn đúng đối với các lời gọi đệ quy sau.\n\nViệc gọi đệ quy sẽ tiếp diễn đến khi:\n1. Xảy ra ngoại lệ hết gas (out-of-gas exception).\n2. Chạm đến giới hạn của stack.\n3. Smart contract `SimpleDAO` không còn ETH nào.\n\n## Cách khắc phục <re-entrancy-remediation>\n\nSử dụng các mẫu bảo mật chẳng hạn như Check-Effect-Interaction hoặc Mutex @wohrer_2018_smart.\n\nMẫu bảo mật Check-Effect-Interaction xếp lời gọi đến smart contract khác ở cuối và sau khi cập nhật biến trạng thái. \n\nVí dụ:\n\n```solidity\npragma solidity 0.4.24;\n\ncontract SimpleDAO {\n  \n  mapping (address => uint) public credit;\n\n  function donate(address to) payable public{\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) public {\n    // 1. Check\n    if (credit[msg.sender]>= amount) {\n      // 2. Effect\n      credit[msg.sender]-=amount;\n      // 3. Interaction\n      require(msg.sender.call.value(amount)());\n    }\n  }  \n\n  function queryCredit(address to) view public returns(uint){\n    return credit[to];\n  }\n  \n}\n```\n\nTrong ví dụ trên, biến trạng thái `credit` được cập nhật trước khi hàm `call` được thực thi.\n\nNgoài ra, cũng có thể sử dụng smart contract ReentrancyGuard của OpenZeppelin @openzeppelin-reentrancy-guard để ngăn chặn các lời gọi đệ quy. Cụ thể, smart contract này cung cấp modifier `nonReentrant` để ngăn cản một smart contract gọi lại chính nó một cách trực tiếp hoặc gián tiếp.\n# Uninitialized Storage Pointer\n\n## Bố cục lưu trữ của Solidity <storage-layout>\n\nTrước khi phân tích lỗ hổng, ta cần hiểu về cách Solidity lưu các biến `storage`. Nói một cách đơn giản, các biến `storage` được Solidity lưu liên tiếp ở trong các khe lưu trữ (slot). Có tổng cộng $2^{256}$ khe lưu trữ, mỗi khe lưu trữ có kích thước 32 byte và được đánh số từ 0 đến $2^{256} - 1$ @voitier_2023_exploring-the-storage-layout-in-solidity-and-how-to-access-state-variables, @a2018_understanding-ethereum-smart-contract-storage. \n\nXét ví dụ sau:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8;\n\ncontract StorageLayout {\n  uint256 x = 1; // slot 0\n  uint256 y = 2; // slot 1\n  uint256 z = 3; // slot 2\n}\n```\n\nDo mỗi biến `x`, `y` và `z` đều có kích thước là 32 byte nên chúng được lưu trong từng slot riêng biệt. \n\nTrong trường hợp kích thước của các biến là nhỏ và vừa đủ một slot, chúng sẽ được đặt cạnh nhau. Ví dụ:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8;\n\n// contract address: 0xeBa088B4182EC4261FA4fd2526F58995Dc1Ec117\n\ncontract StorageLayout {\n    uint16 x = 1;\n    uint16 y = 2;\n    uint16 z = 3;\n}\n```\n\nKhi dùng hàm `web3.eth.getStorageAt(contractAddress, slotPosition)` của thư viện web3.js để truy vấn giá trị được lưu ở slot 0, ta thu được giá trị sau:\n\n```solidity\nslot[0] = 0x0000000000000000000000000000000000000000000000000000000300020001\n```\n\nCó thể thấy, ba biến `x`, `y` và `z` được đặt cạnh nhau. Ngoài ra, giá trị lưu ở slot 0 cũng được ABI-encode @abi-specification bằng cách đệm thêm các số 0.\n\nTrong trường hợp các biến không thể lưu vừa trong một slot, chúng sẽ được lưu vào nhiều slot. Ví dụ:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8;\n\ncontract StorageLayout {\n    uint16 x = 1;\n    uint256 y = 2;\n    uint16 z = 3;\n}\n```\n\nGiá trị của các biến lưu trong các slot là:\n\n```solidity\nslot[0] = 0x0000000000000000000000000000000000000000000000000000000000000001\nslot[1] = 0x0000000000000000000000000000000000000000000000000000000000000002\nslot[2] = 0x0000000000000000000000000000000000000000000000000000000000000003\n```\n\n## Mô tả\n\nCác biến cục bộ có vị trí dữ liệu (data location) là `storage` bên trong hàm nếu không được khởi tạo có thể trỏ đến các biến trạng thái có vị trí dữ liệu là `storage` trong smart contract. Điều này có thể dẫn đến việc giá trị của các biến trạng thái bị sửa đổi thông qua các biến cục bộ. \n\nXét smart contract sau:\n\n```solidity\n// A Locked Name Registrar\ncontract NameRegistrar {\n\n  bool public unlocked = false;  // registrar locked, no name updates\n  \n  struct NameRecord { // map hashes to addresses\n    bytes32 name;\n    address mappedAddress;\n  }\n  \n  mapping(address => NameRecord) public registeredNameRecord; // records who registered names\n  mapping(bytes32 => address) public resolve; // resolves hashes to addresses\n  \n  function register(bytes32 _name, address _mappedAddress) public {\n    // set up the new NameRecord\n    NameRecord newRecord;\n    newRecord.name = _name;\n    newRecord.mappedAddress = _mappedAddress;\n    \n    resolve[_name] = _mappedAddress;\n    registeredNameRecord[msg.sender] = newRecord;\n    \n    require(unlocked); // only allow registrations if contract is unlocked\n  }\n}\n```\n\nSmart contract này có duy nhất một hàm là `register`. Khi biến trạng thái `unlocked` có giá trị là `true`, smart contract cho phép người dùng đăng ký tên và địa chỉ tương ứng với tên đó vào mapping `registeredNameRecord`. Câu lệnh `require` ở cuối hàm giúp hoàn trả giao dịch nếu `unlocked` có giá trị là `false`.\n\nDựa trên cơ chế lưu các biến `storage` của Solidity thì slot 0 sẽ lưu biến `unlocked`, slot 1 lưu biến `registeredNameRecord` và slot 2 lưu biến `resolve` #footnote[Ta bỏ qua việc mapping không thực sự được lưu ở một slot mà thay vào đó là các phần tử của nó được lưu ở các slot không liền kề nhau.].\n\nNhư đã biết, vị trí dữ liệu mặc định cho các biến có kiểu tham chiếu chẳng hạn như struct, mảng hoặc mapping là `storage`. Việc không khai báo vị trí dữ liệu cho biến `newRecord` bên trong hàm `register` làm cho nó có vị trí dữ liệu là `storage`. Do là một biến `storage` và không được khởi tạo, `newRecord` sẽ đóng vai trò là một con trỏ và trỏ đến slot 0. \n\nCụ thể hơn, trường `name` và `mappedAddress` sẽ lần lượt trỏ đến biến `unlocked` và biến `registeredNameRecord`. Việc gán giá trị cho trường `name` khi đó cũng sẽ làm thay đổi giá trị của biến `unlocked`. Bằng cách chọn giá trị `_name` sao cho có bit cuối là 1, kẻ tấn công có thể gọi thực thi hàm `register` để thay đổi biến `unlocked` thành `true`.\n\n## Cách khắc phục\n\nKiểm tra xem biến cục bộ thuộc kiểu tham chiếu có nhất thiết phải là `storage` hay không (thường là không vì điều này làm tăng chi phí thực hiện smart contract do việc ghi vào biến `storage` tiêu thụ rất nhiều gas). Nếu cần thiết thì nên khai báo vị trí dữ liệu tường minh là `storage`. Nếu không thì nên sử dụng vị trí dữ liệu là `memory`.\n\nKể từ phiên bản 0.5.0, vấn đề này đã được giải quyết do các biến `storage` chưa được khởi tạo sẽ không được biên dịch.\n\n\n# Use of Deprecated Solidity Functions\n\n## Mô tả\n\nVới các phiên bản mới của trình biên dịch, việc sử dụng các định danh (identifier) cũ đã bị loại bỏ có thể dẫn đến các lỗi biên dịch hoặc các hành vi không mong muốn.\n\nVí dụ bên dưới có chứa các định danh cũ không còn sử dụng trong các phiên bản trình biên dịch sau này:\n\n```solidity\ncontract DeprecatedSimple {\n\n  function DeprecatedSimple() public { }\n\n  function useDeprecated() public constant {\n    bytes32 blockhash = block.blockhash(0);\n    bytes32 hashofhash = sha3(blockhash);\n\n    uint gas = msg.gas;\n\n    if (gas == 0) {\n      throw;\n    }\n\n    address(this).callcode();\n\n    var a = [1,2,3];\n\n    var (x, y, z) = (false, \"test\", 0);\n\n    suicide(address(0));\n  }\n\n  function () public {}\n}\n```\n\n## Cách khắc phục\n\nSử dụng các định danh thay thế trong smart contract.\n\n#figure(\n  table(\n    columns: (auto, auto),\n    align: horizon,\n    table.header(\"Cũ\", \"Thay thế\"),\n    `suicide(address)`, `selfdestruct(address)`,\n    `block.blockhash(uint)`,\t`blockhash(uint)`,\n    `sha3(...)`, `keccak256(...)`,\n    `callcode(...)`, `delegatecall(...)`,\n    `throw`,\t`revert()`,\n    `msg.gas`,\t`gasleft`,\n    `constant`,\t`view`,\n    `var`,\t[tên kiểu dữ liệu tương ứng],\n    [`function ()`], [`receive()` hoặc `fallback()`],\n    [Hàm tạo trùng tên với smart contract], `constructor()`\n  ),\n  caption: [Các định danh cũ và định danh thay thế tương ứng]\n)\n\nĐối với ví dụ của smart contract `DeprecatedSimple` ở trên, có thể sửa lại như sau:\n\n```solidity\ncontract DeprecatedSimpleFixed {\n\n  constructor() { }\n  \n  function useDeprecatedFixed() public view {\n    bytes32 bhash = blockhash(0);\n    bytes32 hashofhash = keccak256(bhash);\n\n    uint gas = gasleft();\n\n    if (gas == 0) {\n      revert();\n    }\n\n    address(this).delegatecall();\n\n    uint8[3] memory a = [1,2,3];\n\n    (bool x, string memory y, uint8 z) = (false, \"test\", 0);\n\n    selfdestruct(address(0));\n  }\n\n  receive() external payable { }\n\n}\n```\n# Delegatecall to Untrusted Callee\n\n## Hàm `delegatecall`\n\nLà một hàm low-level tương tự với hàm `call` (đều được dùng để gọi hàm của smart contract khác hoặc gửi ETH đến smart contract khác). \n\nTuy nhiên, khi một smart contract A gọi thực thi hàm của smart contract B bằng `delegatecall`, hàm của smart contract B sẽ thực thi với các biến trạng thái của smart contract A.\n\nVí dụ:\n\n```solidity\n// NOTE: Deploy this contract first\ncontract B {\n  \n    // NOTE: storage layout must be the same as contract A\n    uint256 public num;\n    address public sender;\n    uint256 public value;\n\n    function setVars(uint256 _num) public payable {\n      num = _num;\n      sender = msg.sender;\n      value = msg.value;\n    }\n    \n}\n\ncontract A {\n  \n    uint256 public num;\n    address public sender;\n    uint256 public value;\n\n    function setVars(address _contract, uint256 _num) public payable {\n      // A's storage is set, B is not modified.\n      (bool success, bytes memory data) = _contract.delegatecall(\n          abi.encodeWithSignature(\"setVars(uint256)\", _num)\n      );\n    }\n    \n}\n```\n\nTrong ví dụ trên, hàm `setVars(address,uint256)` của smart contract `A` gọi thực thi hàm `setVars(uint256)` của smart contract `B` thông qua hàm `delegatecall`.\n\nTa gọi thực thi hàm `setVars(address,uint256)` với các đối số lần lượt là:\n- Địa chỉ của contract `B` (`0xd2184e03fC9a5deB782691e41fAB0Ba77F52202e`)\n- Giá trị `1`\n\nSau khi thực thi, giá trị của hai biến `num` và `sender` của smart contract `A` sẽ bị thay đổi. Cụ thể:\n- `num` bị thay đổi thành `1`.\n- `sender` bị thay đổi thành địa chỉ gọi hàm `setVars`.\n\n## Mô tả\n\nViệc sử dụng hàm `delegatecall` để gọi hàm của các smart contract không tin cậy là rất nguy hiểm bởi vì các smart contract này có thể thay đổi các giá trị của các biến trạng thái hoặc chiếm quyền sở hữu của smart contract hiện tại.\n\nVí dụ, cho smart contract `Proxy` như sau:\n\n```solidity\ncontract Proxy {\n\n  address owner;\n\n  constructor() {\n    owner = msg.sender;  \n  }\n\n  function getOwner() public view returns (address) {\n    return owner;\n  }\n\n  function forward(address callee, bytes memory _data) public {\n    (bool success, ) = callee.delegatecall(_data);\n    require(success);\n  }\n\n}\n```\n\nHàm `forward` sẽ gọi đến hàm của smart contract có địa chỉ là `callee` thông qua hàm `delegatecall`. Kẻ tấn công có thể xây dựng một smart contract như sau để tấn công:\n\n```solidity\ncontract Attacker {\n    \n  address owner;\n\n  fallback() external { \n    owner = 0xB514b2e847116c7B57e0BFac3a180eB049cd395c;\n  }\n\n}\n```\n\nVới `0xB514b2e847116c7B57e0BFac3a180eB049cd395c` là một địa chỉ mà kẻ tấn công sở hữu.\n\nKẻ tấn công có thể gọi hàm `forward` với:\n- Đối số của `callee` là địa chỉ của smart contract `Attacker` (giả sử là `0xaB35F973D99176552d49030c65B6cB4A82F9254e`).\n- Đối số của `_data` là giá trị rỗng chẳng hạn như `0x00000000000000000000000000000000` nhằm gọi hàm `fallback` của smart contract `Attacker`.\n\nSau khi thực thi, giá trị của `owner` trong smart contract `Proxy` sẽ là: `0xB514b2e847116c7B57e0BFac3a180eB049cd395c`\n\n## Cách khắc phục\n\nCần đảm bảo rằng hàm `delegatecall` không bao giờ gọi đến các smart contract không tin cậy. Nếu địa chỉ của smart contract được gọi hàm là giá trị truyền vào của người dùng thì cần đảm bảo địa chỉ này nằm trong một danh sách các địa chỉ được phép sử dụng (whitelist).\n\n# Denial of Service with Failed Call\n\n## Mô tả\n\nCác lời gọi đến bên ngoài smart contract (thực thi hàm hoặc chuyển ETH) có thể thất bại một cách không có hoặc có chủ đích. Trong trường hợp kẻ tấn công gọi đến bên ngoài smart contract nhiều lần trong cùng một giao dịch, smart contract có thể trở nên không khả dụng.\n\nVí dụ:\n\n```solidity\ncontract DistributeTokens {\n  address public owner; // gets set somewhere\n  address[] investors; // array of investors\n  uint[] investorTokens; // the amount of tokens each investor gets\n\n  // ... extra functionality, including transfertoken()\n\n  function invest() public payable {\n    investors.push(msg.sender);\n    investorTokens.push(msg.value * 5); // 5 times the wei sent\n  }\n\n  function distribute() public {\n    require(msg.sender == owner); // only owner\n    for(uint i = 0; i < investors.length; i++) {\n      // here transferToken(to,amount) transfers \"amount\" of tokens to the address \"to\"\n      transferToken(investors[i],investorTokens[i]);\n    }\n  }\n}\n```\n\nTrong ví dụ này, kẻ tấn công có thể tạo ra một lượng lớn các địa chỉ và lưu vào mảng `investors` thông qua hàm `invest`. Nếu kích thước của mảng `investors` quá lớn, việc lặp qua từng phần tử của nó và thực hiện chuyển token (`transferToken`) có thể gây ra ngoại lệ hết gas (out-of-gas exception). Khi đó, các lời gọi hàm `transferToken` thành công trong giao dịch sẽ bị hủy bỏ và khiến cho smart contract không còn khả dụng.\n\nVí dụ khác, smart contract sau đây thực hiện gửi ETH cho người đặt cược cao nhất.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract BadAuction {\n\n  address payable highestBidder;\n  uint highestBid;\n\n  function bid() public payable {\n    require(msg.value >= highestBid);\n\n    if (highestBidder != address(0)) {\n      highestBidder.transfer(highestBid);\n    }\n\n    highestBidder = payable(msg.sender);\n    highestBid = msg.value;\n  }\n  \n}\n```\n\nSmart contract này có thể bị tấn công DoS nếu kẻ tấn công luôn làm cho hàm `transfer` gây ra ngoại lệ:\n\n```solidity\ncontract Attacker {\n  \n  BadAuction badAuction;\n\n  constructor(address badAuctionAddress) {\n    badAuction = BadAuction(badAuctionAddress);\n  }\n\n  function bid() public payable {\n    badAuction.bid{value: msg.value}();\n  }\n\n  receive() external payable {\n    revert();\n  }\n    \n}\n```\n\nCụ thể, kẻ tấn công sẽ đặt cược và trở thành người đặt cược lớn nhất thông qua hàm `bid` của smart contract `Attacker`. Sau đó, không ai có thể trở thành người đặt cược lớn nhất được nữa do hàm `fallback` của `Attacker` luôn gây ra ngoại lệ và hoàn trả giao dịch. Điều này làm mất đi tính sẵn sàng của smart contract.\n\n## Cách khắc phục\n\nNhững điều cần lưu ý khi thực hiện gọi đến bên ngoài smart contract:\n- Không gọi đến bên ngoài smart contract nhiều lần trong cùng một giao dịch.\n- Luôn giả định rằng lời gọi đến bên ngoài smart contract có thể thất bại.\n- Xử lý các lời gọi thất bại.\n\nĐối với việc chuyển ETH, có thể áp dụng mẫu bảo mật Pull-over-Push @solidity-patterns để tạo ra một hàm cho phép người dùng có thể rút ETH thay vì tự động chuyển cho họ. \n\nVí dụ:\n\n```solidity\ncontract PullOverPush {\n\n  mapping(address => uint) credits;\n\n  function allowForPull(address receiver, uint amount) private {\n    credits[receiver] += amount;\n  }\n\n  function withdrawCredits() public {\n    uint amount = credits[msg.sender];\n\n    require(amount != 0);\n    require(address(this).balance >= amount);\n\n    credits[msg.sender] = 0;\n\n    msg.sender.transfer(amount);\n  }\n}\n```\n# Authorization through `tx.origin`\n\n## Mô tả\n\nLỗ hổng này xảy ra khi smart contract dùng giá trị `tx.origin` để xác thực. Giá trị này là giá trị của địa chỉ thực hiện giao dịch và nếu smart contract A có gọi thực thi hàm của smart contract B thì smart contract B có thể vượt qua xác thực của smart contract A.\n\nVí dụ, xét hai smart contract sau:\n\n```solidity\ncontract VictimContract {\n  \n  address owner;\n\n  constructor() {\n    owner = payable(msg.sender);\n  }\n\n  function withdrawFunds(address to) public {\n    require(tx.origin == owner);\n    uint256 contractBalance = address(this).balance;\n    (bool suceed, ) = to.call{value: contractBalance}(\"\");\n    require(suceed, \"Failed withdrawal\");\n  }\n  \n}\n\ncontract Attacker {\n  \n  address owner;\n  VictimContract victim;\n  \n  constructor(VictimContract _victim) {\n    owner = payable(msg.sender);\n    victim = VictimContract(_victim);\n  }\n  \n  receive() external payable {\n    victim.withdrawFunds(owner);\n  }\n  \n}\n```\n\nSmart contract `VictimContract` cho phép chủ sở hữu rút ETH thông qua hàm `withdrawFunds` bằng cách dùng hàm `call` để gửi ETH cho địa chỉ `to`. Hàm này thực hiện xác thực bằng cách so sánh `tx.origin` với địa chỉ của chủ sở hữu. \n\nĐể nhận ETH, smart contract `Attacker` đã cài đặt hàm `receive`. Tuy nhiên, hàm này thực hiện gọi lại hàm `withdrawFunds` của `VictimContract` với đối số là `owner` của `Attacker`.\n\nKẻ tấn công sẽ tìm cách dụ chủ sở hữu của smart contract chuyển ETH cho `Attacker`. Khi đó, `tx.origin` sẽ có giá trị là `owner` và việc gọi lại hàm `withdrawFunds` của `Attacker` sẽ thỏa điều kiện xác thực `tx.origin == owner`.\n\n## Cách khắc phục\n\nSử dụng `msg.sender` thay vì `tx.origin` để xác thực.\n# Signature Malleability\n\n## Thuật toán chữ ký số trên đường cong elliptic (ECDSA)\n\nEthereum sử dụng thuật toán chữ ký số trên đường cong elliptic (ECDSA). Đường cong mà thuật toán này sử dụng là secp256k1 có phương trình như sau:\n\n$\ny^2 = x^3 + 7\n$\n\n#figure(\n  image(\"imgs/secp256k1.png\"),\n  caption: [Đồ thị của đường cong Elliptic]\n)\n\nCó thể thấy, đồ thị đối xứng qua trục x. Đây là một tính chất quan trọng góp phần tạo ra lỗ hổng.\n\nTrong ECDSA, chữ ký được biểu diễn bằng cặp số $(r, s)$. Quá trình tạo ra chữ ký @what-is-the-ecdsa:\n- Thuật toán sẽ chọn một con số nguyên $k$ ngẫu nhiên với $1 < k < n$ và $n$ là số lượng điểm có trong đường cong secp256k1 (là một số nguyên tố).\n- Sau đó, tạo ra điểm $R$ với $R = k * G$ (G là phần tử sinh của đường cong secp256k1). Giá trị $r$ là tọa độ x của điểm $R$.\n- Tính toán bằng chứng chữ ký $s$ với công thức sau: $s = k^-1 * (h + d * r) mod n$ với $h$ là giá trị băm của thông điệp cần ký và $d$ là khóa riêng tư.\n\nQuy trình xác thực chữ ký:\n- Tính toán giá trị băm của thông điệp và nghịch đảo modulo của $s$ (ta gọi là $s'$).\n- Khôi phục điểm $R$ được sinh ra trong qua trình ký bằng công thức sau: $R' = (h * s') * G + (r * s') * e$ với $e$ là khóa công khai.\n- So sánh tọa độ x của $R'$ với tọa độ x của $R$ (giá trị $r$). Nếu hai giá trị này bằng nhau thì tức là chữ ký hợp lệ.\n\nDo tính đối xứng, nếu $(r, s)$ là một chữ ký hợp lệ thì $(r, -s \\mod n)$ cũng là một chữ ký hợp lệ.\n\n## Mô tả\n\nCác hệ thống chữ ký mật mã của Ethereum được hiện thực với giả định rằng chữ ký số là duy nhất. Smart contract hoạt động dựa trên giả định này có thể bị tấn công vì kẻ tấn công có thể chỉnh sửa các giá trị v, r và s của một chữ ký để tạo ra một chữ ký hợp lệ khác mà không cần biết khóa riêng tư (dựa vào tính đối xứng). \n\nVí dụ bên dưới minh họa cho quá trình xác thực chữ ký trong Solidity:\n\n```solidity\n// source: https://medium.com/draftkings-engineering/signature-malleability-7a804429b14a\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract SignatureMalleability{\n\n  function verify(bytes32 _messageHash, bytes memory _sig, address _expectedSigner) \n  public pure returns (bool) {\n    bytes32 ethSignedHash = keccak256(\n      abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _messageHash)\n    );\n    address signer = recoverSigner(ethSignedHash, _sig);\n    return signer == _expectedSigner;\n  }\n\n  function recoverSigner(bytes32 _ethSignedHash, bytes memory _sig) \n  public pure returns (address) {\n    require(_sig.length == 65, \"Invalid signature length\");\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n    assembly {\n      r := mload(add(_sig, 32))\n      s := mload(add(_sig, 64))\n      v := byte(0, mload(add(_sig, 96)))\n    }\n    if (v < 27) {\n      v += 27;\n    }\n    require(v == 27 || v == 28, \"Invalid signature v value\");\n    return ecrecover(_ethSignedHash, v, r, s);\n  }\n\n}\n```\n\nTrong ví dụ trên, hàm `verify` băm giá trị `_messageHash` theo chuẩn được nêu trong EIP-191 @eip-191 rồi gọi hàm `recoverSigner` để khôi phục địa chỉ người ký từ giá trị băm và chữ ký.\n\nCác dòng mã hợp ngữ trong hàm `recoverSigner` được dùng để tách giá trị `_sig` thành các giá trị $r$, $s$ và $v$. Với $v$ là giá trị giúp việc khôi phục địa chỉ người ký dễ dàng hơn. Nếu địa chỉ trả về từ hàm `ecrecover` khớp với đối số truyền vào tham số `_expectedSigner` của hàm `verify` thì chữ ký là hợp lệ.\n\nKẻ tấn công có thể xây dựng smart contract như sau:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Attack{\n\n  function manipulateSignature(bytes memory signature) public pure returns(bytes memory) {\n    (uint8 v, bytes32 r, bytes32 s) = splitSignature(signature);\n\n    uint8 manipulatedV = v % 2 == 0 ? v - 1 : v + 1;\n    uint256 manipulatedS = modNegS(uint256(s));\n    bytes memory manipulatedSignature = abi.encodePacked(r, bytes32(manipulatedS), manipulatedV);\n\n    return manipulatedSignature;\n  }\n\n  function splitSignature(bytes memory sig) public pure returns (uint8 v, bytes32 r, bytes32 s) {\n    require(sig.length == 65, \"Invalid signature length\");\n    assembly {\n      r := mload(add(sig, 32))\n      s := mload(add(sig, 64))\n      v := byte(0, mload(add(sig, 96)))\n    }\n    if (v < 27) {\n      v += 27;\n    }\n    require(v == 27 || v == 28, \"Invalid signature v value\");\n  }\n\n  function modNegS(uint256 s) public pure returns (uint256) {\n    uint256 n = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141;        \n    return n - s;\n  }\n\n}\n```\n\nCó thể thấy, hàm `manipulateSignature` tách các thành phần $r$, $s$ và $v$ từ `signature` thông qua hàm `splitSignature`. Sau đó, nó chỉnh sửa giá trị của $v$ sao cho nếu $v$ là chẵn thì trừ đi 1 còn nếu $v$ là lẻ thì cộng thêm 1. Giá trị $s$ sẽ được chỉnh sửa thành $-s mod n$ (được tính thông qua hàm `modNegS`). Cuối cùng, ba giá trị $r$, $s$ và $v$ được ghép lại thành chữ ký thông qua hàm `abi.encodePacked`.\n\nNhư vậy, nếu kẻ tấn công biết được một chữ ký hợp lệ thì có thể dùng hàm `manipulateSignature` để tạo ra một chữ ký hợp lệ khác.\n\n## Cách khắc phục\n\nKhông dùng chữ ký số để xây dựng định danh của giao dịch dùng để chống tấn công lặp lại chữ ký số (@signature-replay). Lý do là vì kẻ tấn công có thể tạo ra một định danh khác sử dụng một chữ ký số khác dựa trên tính dễ uốn của chữ ký số nhưng vẫn thỏa được quá trình xác thực.\n\nCũng có thể sử dụng smart contract `ECDSA` của OpenZeppelin @openzeppelin-cryptography-ecdsa.\n# Incorrect Constructor Name\n\n## Mô tả\n\nTrong hàm tạo của Solidity thường thực hiện những hành động đặc quyền chẳng hạn như thiết lập chủ sở hữu của smart contract. Trước phiên bản 0.4.22, hàm tạo có tên trùng với tên smart contract. Tuy nhiên, nếu một hàm đáng lẽ được dùng làm hàm tạo nhưng có tên không trùng với tên của smart contract thì nó sẽ trở thành một hàm bình thường và có thể được gọi bởi bất kỳ ai.\n\nVí dụ:\n\n```solidity\n/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/incorrect_constructor.sol\n * @author: Ben Perez\n * Modified by Gerhard Wagner\n */\n\npragma solidity 0.4.24;\n\ncontract Missing {\n  \n  address private owner;\n\n  modifier onlyowner {\n    require(msg.sender==owner);\n    _;\n  }\n\n  function missing() public {\n    owner = msg.sender;\n  }\n\n  function () payable { } \n\n  function withdraw() public onlyowner {\n   owner.transfer(this.balance);\n  }\n  \n}\n```\n\nTrong ví dụ trên, hàm `missing` đáng lẽ là hàm tạo nhưng có tên không trùng với tên của smart contract `Missing`. Điều này khiến cho bất kỳ ai cũng có thể gọi hàm `missing` để trở thành chủ sở hữu của smart contract.\n\n## Cách khắc phục\n\nKể từ phiên bản 0.4.22, hàm tạo có tên là `constructor`. Lập trình viên nên nâng cấp phiên bản của smart contract để tránh lỗ hổng này.\n# Shadowing State Variables\n\n## Mô tả\n\nXảy ra khi một smart contract kế thừa smart contract khác và cả hai đều cùng khai báo một biến. Vấn đề này cũng xảy ra khi smart contract có một biến toàn cục trùng tên với một biến cục bộ ở trong hàm.\n\nVí dụ:\n\n```solidity\npragma solidity 0.4.24;\n\ncontract Tokensale {\n  \n  uint hardcap = 10000 ether;\n\n  function Tokensale() {}\n\n  function fetchCap() public constant returns(uint) {\n    return hardcap;\n  }\n  \n}\n\ncontract Presale is Tokensale {\n  \n  uint hardcap = 1000 ether;\n\n  function Presale() Tokensale() {}\n  \n}\n```\n\nTrong ví dụ trên, giá trị trả về khi gọi hàm `fetchCap` từ smart contract `Presale` là 10,000 ETH thay vì 1,000 ETH. Nói cách khác, biến `hardcap` ở trong `Presale` không ghi đè biến `hardcap` ở trong `Tokensale` và điều này có thể làm ảnh hưởng đến kết quả thực thi của smart contract.\n\n## Cách khắc phục\n\nNếu muốn ghi đè biến trạng thái của smart contract được kế thừa, ta có thể gán giá trị mới cho nó ở trong hàm tạo của smart contract kế thừa. Ví dụ:\n\n```solidity\ncontract Presale is Tokensale {\n  \n  // uint hardcap = 1000 ether;\n  \n  function Presale() Tokensale() {\n    hardcap = 1000 ether;\n  }\n  \n}\n```\n\nKể từ phiên bản 0.6.0 @solidity-v0.6.0-breaking-changes, việc shadowing các biến trạng thái sẽ được phát hiện bởi trình biên dịch.\n# Weak Sources of Randomness from Chain Attributes\n\n## Mô tả\n\nNhu cầu sinh số ngẫu nhiên là rất cần thiết cho một số ứng dụng, đặc biệt là các trò chơi cần sử dụng bộ sinh số giả ngẫu nhiên (pseudo-random number generator) để quyết định người chiến thắng. Tuy nhiên, việc tạo ra một hạt giống sinh số ngẫu nhiên đủ mạnh trong Ethereum là rất khó khăn.\n\nCụ thể, việc sử dụng giá trị `block.timestamp` làm hạt giống có thể không bảo mật vì giá trị này có thể được chỉnh sửa bởi miner (như trong @timestamp-dependency). \n\nViệc sử dụng `blockhash` hoặc `block.difficulty` cũng tương tự vì các giá trị này được kiểm soát bởi miner. Nếu thời gian để đào một block là ngắn, miner có thể đào thật nhiều block và chọn block có giá trị băm thỏa mãn điều kiện chiến thắng của smart contract rồi bỏ các block còn lại.\n\nVí dụ:\n\n```solidity\n/*\n * @source: https://capturetheether.com/challenges/lotteries/guess-the-random-number/\n * @author: Steve Marx\n */\n\npragma solidity ^0.4.21;\n\ncontract GuessTheRandomNumberChallenge {\n  \n  uint8 answer;\n\n  function GuessTheRandomNumberChallenge() public payable {\n    require(msg.value == 1 wei);\n    answer = uint8(keccak256(block.blockhash(block.number - 1), now));\n  }\n\n  function isComplete() public view returns (bool) {\n    return address(this).balance == 0;\n  }\n\n  function guess(uint8 n) public payable {\n    require(msg.value == 1 wei);\n\n    if (n == answer) {\n        msg.sender.transfer(2 wei);\n    }\n  }\n  \n}\n```\n\nThông tin về số block (`block.number`) và thời gian của mà block được tạo ra (`now` - tương ứng với `block.timestamp` ở các phiên bản sau này của Solidity) đều được công khai nên kẻ tấn công có thể dễ dàng tái tạo được giá trị của `answer`.\n\n## Cách khắc phục <weak-sources-of-randomness-from-chain-attributes-remediation>\n\nMột số giải pháp sinh số ngẫu nhiên/giả ngẫu nhiên:\n\n*Verifiable Random Function (VRF)*\n\nSử dụng các VRF @introduction-to-chainlink-vrf để tạo số ngẫu nhiên có thể xác thực. Với mỗi yêu cầu sinh số ngẫu nhiên, sẽ có một hoặc nhiều số ngẫu nhiên được tạo ra off-chain (bên ngoài blockchain) và đi kèm với chúng là các bằng chứng mật mã (cryptographic proof) cho biết cách mà các số ngẫu nhiên được hình thành. \n\nBằng chứng mật mã sẽ được công khai và được xác thực on-chain trước khi các ứng dụng có thể sử dụng. Điều này đảm bảo các giá trị ngẫu nhiên không bị giả mạo hoặc thao túng bởi một thực thể nào đó.\n\n*Commit-Reveal Scheme*\n\nCũng có thể dùng mô hình commit-reveal @atzei_2017_a. Mô hình này hoạt động như sau: mỗi thành viên tham gia vào việc tạo số ngẫu nhiên sẽ sinh ra một con số bí mật và công khai giá trị băm của số bí mật này kèm với một khoảng tiền đặt cọc. \n    \nSau một thời gian nhất định, các thành viên này sẽ phải công khai con số bí mật tương ứng với giá trị băm đã công khai trước đó. Số giả ngẫu nhiên sẽ được tính toán dựa trên những con số bí mật này. Nếu có một thành viên không công khai số bí mật, thành viên đó sẽ bị mất khoản tiền đặt cọc.\n\nMột hiện thực của mô hình này trong thực tế là RANDAO @a2020_randao.\n\n*Bitcoin Hashes*\n\nGiá trị hash của Bitcoin cũng có thể được dùng làm hạt giống sinh số ngẫu nhiên bởi vì các block trong Bitcoin thường khó để đào hơn.\n# Missing Protection against Signature Replay Attacks <signature-replay>\n\n## Mô tả\n\nLỗ hổng này xảy ra khi smart contract thực hiện xác thực chữ ký nhưng không kiểm tra xem chữ ký đã được sử dụng hay chưa. Kẻ tấn công có thể tái sử dụng chữ ký nhiều lần để vượt qua xác thực và thực thi hàm.\n\nVí dụ @signature-replay-ref:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"./ECDSA.sol\";\n\ncontract MultiSigWallet {\n  \n  using ECDSA for bytes32;\n\n  address[2] public owners;\n\n  constructor(address[2] memory _owners) payable { owners = _owners; }\n\n  function deposit() external payable { }\n\n  function transfer(address _to, uint256 _amount, bytes[2] memory _sigs)\n    external\n  {\n    bytes32 txHash = getTxHash(_to, _amount);\n    require(_checkSigs(_sigs, txHash), \"invalid sig\");\n\n    (bool sent,) = _to.call{value: _amount}(\"\");\n    require(sent, \"Failed to send Ether\");\n  }\n\n  function getTxHash(address _to, uint256 _amount)\n    public\n    view\n    returns (bytes32)\n  {\n    return keccak256(abi.encodePacked(_to, _amount));\n  }\n\n  function _checkSigs(bytes[2] memory _sigs, bytes32 _txHash)\n    private\n    view\n    returns (bool)\n  {\n    bytes32 ethSignedHash = _txHash.toEthSignedMessageHash();\n\n    for (uint256 i = 0; i < _sigs.length; i++) {\n      address signer = ethSignedHash.recover(_sigs[i]);\n      bool valid = signer == owners[i];\n\n      if (!valid) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  \n}\n```\n\nTrong ví dụ trên, hàm `transfer` có các tham số sau:\n- Địa chỉ nhận ETH: `_to`.\n- Lượng ETH cần chuyển: `_amount`.\n- Hai chữ ký của hai chủ sở hữu ví: `memory _sigs`.\n\nHàm `transfer` xây dựng văn bản sẽ được ký bằng cách băm giá trị `txHash` theo chuẩn được nêu trong EIP-191 @eip-191. Sau đó, nó gọi hàm `_checkSigs` để kiểm tra xem địa chỉ được khôi phục từ hai chữ ký có khớp với địa chỉ của các chủ sở hữu ví hay không.\n\nDo smart contract không kiểm tra sự giống nhau của các chữ ký trong những lần gọi hàm khác nhau, kẻ tấn công có thể dùng lại các chữ ký cũ (lấy được thông qua các giao dịch trước đó) để chuyển tiền đến địa chỉ `_to` với lượng ETH là `_amount` (giả sử `_to` là một địa chỉ mà kẻ tấn công sở hữu).\n\n## Cách khắc phục\n\nCó thể lưu lại danh sách các chữ ký đã được sử dụng và thêm một giá trị dùng một lần (nonce) vào văn bản cần ký để các chữ ký sử dụng trong những lần gọi hàm khác nhau là khác nhau. Kẻ tấn công dù biết được giá trị nonce này cũng không có khóa riêng tư của các chủ sở hữu ví để tạo ra các chữ ký hợp lệ.\n\nVí dụ @signature-replay-ref:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"./ECDSA.sol\";\n\ncontract MultiSigWallet {\n  \n  using ECDSA for bytes32;\n\n  address[2] public owners;\n  mapping(bytes32 => bool) public executed;\n\n  constructor(address[2] memory _owners) payable { owners = _owners; }\n\n  function deposit() external payable {}\n\n  function transfer(\n    address _to,\n    uint256 _amount,\n    uint256 _nonce,\n    bytes[2] memory _sigs\n  ) external {\n    bytes32 txHash = getTxHash(_to, _amount, _nonce);\n    require(!executed[txHash], \"tx executed\");\n    require(_checkSigs(_sigs, txHash), \"invalid sig\");\n\n    executed[txHash] = true;\n\n    (bool sent,) = _to.call{value: _amount}(\"\");\n    require(sent, \"Failed to send Ether\");\n  }\n\n  function getTxHash(address _to, uint256 _amount, uint256 _nonce)\n    public\n    view\n    returns (bytes32)\n  {\n    return keccak256(abi.encodePacked(address(this), _to, _amount, _nonce));\n  }\n\n  // ...\n  \n}\n```\n\nTrong ví dụ trên, smart contract sử dụng biến `executed` để lưu lại những chữ ký đã được sử dụng. Ngoài ra, văn bản được ký có thêm giá trị `_nonce`. Giá trị này có thể là một số nguyên ngẫu nhiên hoặc tăng dần tùy thuộc vào chủ sở hữu ví.\n\n\n\n# Lack of Proper Signature Verification\n\n## Mô tả\n\nXảy ra khi smart contract không thực hiện kiểm tra tính hợp lệ của chữ ký khi thực hiện những thao tác nhạy cảm. Kẻ tấn công có thể lợi dụng điều này để vượt qua xác thực nhằm thực hiện những hành vi không được phép.\n\n## Cách khắc phục\n\nKhông sử dụng các cách kiểm tra tính hợp lệ của chữ ký mà không thông qua hàm `ecrecover`.\n# Write to Arbitrary Storage Location\n\n## Mô tả\n\nSmart contract cần phải đảm bảo rằng các vị trí lưu trữ dữ liệu nhạy cảm chỉ có thể được truy cập và chỉnh sửa bởi địa chỉ của người dùng hoặc smart contract mà đã được phân quyền. Nếu một kẻ tấn công có khả năng thay đổi giá trị của bất kỳ vị trí lưu trữ nào thì có thể vượt qua xác thực và thay đổi giá trị của các biến trạng thái.\n\nVí dụ @solidity-array-overflow:\n\n```solidity\npragma solidity ^0.4.17; \n\ncontract ArrayLengthManipulation{\n  \n  uint256 target = 10;\n  uint256[] array = [9,8];\n\n  function modifyArray (uint256 _index, uint256 _value){\n    array[_index] = _value;\n  }\n\n  function popLength() public{\n    // cause overflow\n    array.length--;\n  }\n\n  function getLength() constant returns(uint256){\n    return array.length;\n  }\n\n}\n```\n\nMục tiêu của kẻ tấn công là thay đổi giá trị của biến `target`.\n\nTrước tiên, kẻ tấn công sẽ gọi hàm `popLength` 3 lần để giảm kích thước #footnote[Trước phiên bản 0.6.0, kích thước của mảng động có thể được điều chỉnh thông qua thuộc tính `length` của mảng] của mảng `array` xuống $-1 = 2^{256} - 1$ (giá trị dạng thập lục phân là `0xff..ff`). Lúc đó, kích thước của mảng bằng với kích thước của mảng các slot (tính luôn cả slot lưu kích thước mảng). Điều này khiến cho chỉ số của các phần tử trong mảng cũng là chỉ số của các slot (bố cục lưu trữ theo các slot được đề cập trong phần @storage-layout[]).\n\nDo `array` được lưu ở slot 1, chỉ số slot lưu dữ liệu của phần tử đầu tiên là giá trị băm Keccak-256 của chuỗi `0x0000000000000000000000000000000000000000000000000000000000000001`:\n\n```\n0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6\n```\n\nCác phần tử của mảng nằm ở slot `0xff..ff` trở đi sẽ bị chồng chéo. Ví dụ, chỉ số `0xff..ff` sẽ tương ứng với chỉ số $2^{256} mod 2^{256} = 0$, chỉ số `0xff..ff + 1` sẽ tương ứng với chỉ số $2^{256} + 1 mod 2^{256} = 1$, ...\n\nMinh họa: \n\n#figure(\n  image(\"imgs/Write to arbitrary storage location.png\"),\n  caption: [Chồng chéo không gian lưu trữ]\n)\n\nTrong hình minh họa trên, hai slot cuối cùng sẽ bị chồng chéo với slot 0 và slot 1. Kẻ tấn công sẽ cần phải tìm chỉ số mảng tương ứng với slot cần thay đổi giá trị. Cụ thể, chỉ số mảng tương ứng với slot 0 sẽ là:\n\n```\n0xff..ff - 0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6 + 0\n```\n\nCông thức tổng quát:\n\n$\ni = 2^{256} - i_a + i_b\n$\n\nVới:\n- $i$ là chỉ số mảng cần tìm.\n- $i_a$ là chỉ số slot của phần tử đầu tiên trong mảng.\n- $i_b$ là chỉ số slot của biến cần thay đổi giá trị.\n\nSau khi có được chỉ số mảng thì kẻ tấn công sẽ gọi hàm `modifyArray` để thay đổi giá trị của biến `target` thông qua mảng `array`.\n\n## Cách khắc phục\n\nCần phải đảm bảo rằng việc thay đổi giá trị của một cấu trúc dữ liệu không làm thay đổi dữ liệu của các cấu trúc dữ liệu khác.\n\nNgoài ra, đối với ví dụ ở trên, kể từ phiên bản 0.6.0, thuộc tính `length` của mảng động chỉ có thể đọc chứ không thể ghi.\n# Incorrect Inheritance Order\n\n## Đa kế thừa trong Solidity\n\nSolidity hỗ trợ đa kế thừa nên nếu một smart contract kế thừa nhiều smart contract thì có thể dẫn đến vấn đề kim cương (Diamon Problem): nếu có hai hoặc nhiều smart contract cơ sở cùng định nghĩa một hàm, hàm nào sẽ được gọi sử dụng trong smart contract dẫn xuất? \n\nGiả sử có smart contract `A` như sau @on-crowdsales-and-multiple-inheritance:\n\n```solidity\ncontract A {\n  \n  function f() {\n    somethingA();\n  }\n  \n}\n```\n\nSmart contract `B` và `C` kế thừa `A`. Hai smart contract này đều ghi đè hàm `f`:\n\n```solidity\ncontract B is A {\n\n  function f() {\n    somethingB();\n    super.f();\n  }\n  \n}\n\ncontract C is A {\n  \n  function f() {\n    somethingC();\n    super.f();\n  }\n  \n}\n```\n\nCuối cùng, smart contract `D` kế thừa `B` và `C`:\n\n```solidity\ncontract D is B, C {\n  \n  function f() { \n    somethingD();\n    super.f();\n  }\n  \n}\n```\n\nCâu hỏi đặt ra là: khi `D` gọi hàm `f`, hàm `f` trong `B` hay hàm `f` trong `C` sẽ được gọi?\n\nSolidity xử lý vấn đề này bằng cách sử dụng tuyến tính hóa siêu lớp C3 đảo ngược @multiple-inheritance-and-linearization để thiết lập độ ưu tiên cho các smart contract.\n\nNói một cách đơn giản, khi một hàm được sử dụng trong smart contract dẫn xuất mà có nhiều định nghĩa trong các smart contract cơ sở, Solidity sẽ tìm kiếm định nghĩa của hàm trong các smart contract cơ sở từ phải sang trái (từ cụ thể đến tổng quát) và sẽ sử dụng định nghĩa đầu tiên mà nó tìm thấy.\n\nTrong ví dụ trên, Solidity sẽ gọi hàm theo thứ tự sau:\n\n```solidity\nsomethingD(); \nsomethingC(); \nsomethingB(); \nsomethingA();\n```\n\nHàm `f` của smart contract `C` sẽ được ưu tiên hơn hàm `f` của smart contract `B` do `C` được khai báo sau (cụ thể hơn). Ngoài ra, mặc dù smart contract `C` không kế thừa smart contract `B`, hàm `f` của `B` vẫn được gọi thông qua `super.call()` trong hàm `f` của `C`.\n\n## Mô tả\n\nDo mỗi smart contract cơ sở đều có độ ưu tiên, việc không quan tâm thứ tự kế thừa có thể dẫn đến những hành vi không mong muốn của smart contract.\n\n## Cách khắc phục\n\nKhi sử dụng đa kế thừa, cần cẩn thận trong việc sắp xếp thứ tự kế thừa của các smart contract cơ sở mà có các hàm giống nhau. Nguyên tắc chung là kế thừa các smart contract từ tổng quát đến cụ thể.\n# Insufficient Gas Griefing\n\n## Mô tả\n\nXảy ra khi smart contract không kiểm tra xem nó có đủ gas để gọi đến smart contract khác hay không. Kẻ tấn công có thể cung cấp thiếu gas nhằm khiến cho lời gọi đến smart contract khác bị thất bại và làm kết quả của smart contract bị sai lệch.\n\nVí dụ:\n\n```solidity\n/*\n * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/#insufficient-gas-griefing\n * @author: ConsenSys Diligence\n * Modified by Kaden Zipfel\n */\n\npragma solidity ^0.5.0;\n\ncontract Relayer {\n  \n  uint transactionId;\n\n  struct Tx {\n    bytes data;\n    bool executed;\n  }\n\n  mapping (uint => Tx) transactions;\n\n  function relay(Target target, bytes memory _data) public returns(bool) {\n    // replay protection; do not call the same transaction twice\n    require(transactions[transactionId].executed == false, 'same transaction twice');\n    transactions[transactionId].data = _data;\n    transactions[transactionId].executed = true;\n    transactionId += 1;\n\n    (bool success, ) = address(target).call(abi.encodeWithSignature(\"execute(bytes)\", _data));\n    return success;\n  }\n  \n}\n\ncontract Target {\n  \n  function execute(bytes memory _data) public {\n    // Execute contract code\n  }\n  \n}\n```\n\nTrong ví dụ trên, smart contract `Relayer` thực hiện chuyển tiếp lời gọi hàm đến smart contract `Target` thông qua hàm `relay`. Cụ thể, hàm `relay` dùng hàm `call` để gọi đến hàm `execute` của smart contract `Target`.\n\nKẻ tấn công có thể chỉ cung cấp lượng gas vừa đủ để thực thi hàm `relay` nhưng không đủ để thực thi hàm `execute`. Khi đó, hàm `execute` sẽ gây ra ngoại lệ hết gas (out-of-gas exception). Nếu `Relayer` không kiểm tra và hoàn trả giao dịch dựa trên giá trị trả về của hàm `call` thì có thể làm ảnh hưởng đến kết quả thực thi của smart contract.\n\n## Cách khắc phục\n\nKiểm tra xem lượng gas được cung cấp có đủ để thực thi lời gọi hàm đến smart contract khác hay không. \n\nVí dụ @oualid_2022_smart-contract-gas-griefing-attack:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract Relayer {\n  uint public estimatedGasValue = 1000000;\n  uint public gasNeededBetweenCalls = 5000;\n  \n  uint transactionId;\n\n  struct Tx {\n    bytes data;\n    bool executed;\n  }\n\n  mapping (uint => Tx) transactions;\n\n  function relay(Target target, bytes memory _data) public returns(bool) {\n    // replay protection; do not call the same transaction twice\n    require(transactions[transactionId].executed == false, 'same transaction twice');\n    transactions[transactionId].data = _data;\n    transactions[transactionId].executed = true;\n    transactionId += 1;\n\n    uint gasAvailable = gasleft() - gasNeededBetweenCalls;\n    require(gasAvailable - gasAvailable/64 >= estimatedGasValue, \"not enough gas provided\");\n    \n    (bool success, ) = address(target).call(abi.encodeWithSignature(\"execute(bytes)\", _data));\n    return success;\n  }\n  \n}\n```\n\nTrong ví dụ trên, giá trị `estimatedGasValue` là lượng gas ước lượng cần để thực thi hàm `execute` còn giá trị `gasNeededBetweenCalls` là lượng gas cần dùng để thực hiện hai dòng lệnh trước lời gọi hàm `call`. Lý do trừ đi `gasAvailable/64` là vì 1/64 lượng gas khả dụng trong smart contract sẽ được giữ lại ở `Relayer` @eip-150-and-the-63-64-rule-for-gas.\n\nNgoài ra, nên giới hạn danh sách người dùng tin cậy có thể thực thi các hàm chuyển tiếp trong smart contract.\n# Arbitrary Jump with Function Type Variable\n\n## Kiểu dữ liệu hàm trong Solidity\n\nLà một tham chiếu đến hàm với một nguyên mẫu hàm cụ thể. Biến thuộc kiểu dữ liệu này có thể được gọi thực thi tương tự như các hàm thông thường.\n\nVí dụ, đoạn mã sau giúp thay đổi hàm cần thực thi giữa `add` và `sub` một cách linh động khi chạy:\n\n```solidity\n// source: https://medium.com/authio/solidity-ctf-part-2-safe-execution-ad6ded20e042\npragma solidity ^0.4.23;\n\ncontract AddSub {\n    \n  function add(uint a, uint b) internal pure returns (uint) {\n    return a + b;\n  }\n  \n  function sub(uint a, uint b) internal pure returns (uint) {\n    return a - b;\n  }\n  \n  function math(uint _a, uint _b, bool _add) public pure returns (uint) {\n    function (uint, uint) internal pure returns (uint) func;\n    func = _add ? add : sub;\n    return func(_a, _b);\n  }\n}\n```\n\n## Mô tả\n\nKẻ tấn công có thể sử dụng các chỉ thị hợp ngữ (assembly instruction) chẳng hạn như `mstore` hoặc toán tử gán bằng để thay đổi tham chiếu của biến có kiểu là hàm đến bất kỳ chỉ thị nào nhằm phá vỡ các giới hạn truy cập và thay đổi các biến trạng thái.\n\nTrong ví dụ bên dưới, cách duy nhất để kẻ tấn công gọi hàm `withdraw()` để rút ETH là thông qua hàm `breakIt()`. Tuy nhiên, câu lệnh `require()` trong hai hàm này mâu thuẫn với nhau và mục tiêu của kẻ tấn công là vượt qua được câu lệnh `require()` ở trong hàm `withdraw()`.\n\n```solidity\n/*\n * @source: https://gist.github.com/wadeAlexC/7a18de852693b3f890560ab6a211a2b8\n * @author: Alexander Wade\n */\n\npragma solidity ^0.4.25;\n\ncontract FunctionTypes {\n\n  constructor() public payable { require(msg.value != 0); }\n\n  function withdraw() private {\n    require(msg.value == 0, 'dont send funds!');\n    address(msg.sender).transfer(address(this).balance);\n  }\n\n  function frwd() internal { \n    withdraw(); \n  }\n\n  struct Func { \n    function () internal f; \n  }\n\n  function breakIt() public payable {\n    require(msg.value != 0, 'send funds!');\n    Func memory func;\n    func.f = frwd;\n    assembly { \n      mstore(func, add(mload(func), callvalue))\n    }\n    func.f();\n  }\n}\n```\n\nLỗ hổng tồn tại trong đoạn mã hợp ngữ giúp trỏ biến `func` đến vị trí của một chỉ thị ở trong bytecode.\n\n- Mã lệnh `mstore` có nguyên mẫu hàm là `mstore(p, v)` và được dùng để lưu giá trị `v` vào vùng nhớ `p`. \n- Giá trị sẽ được lưu vào vùng nhớ là `add(mload(func), callvalue)`. Với:\n  - Mã lệnh `callvalue` giúp đẩy `msg.value` vào ngăn xếp.\n  - Mã lệnh `mload` giúp đẩy giá trị vùng nhớ ban đầu của `func` lên ngăn xếp.\n\nĐể nhảy đến một ví trí bất kỳ, mà cụ thể là sau câu lệnh `require()` ở trong hàm `withdraw()`, kẻ tấn công chỉ cần dựa trên giá trị ban đầu của `func` và vị trí của chỉ thị cần nhảy đến ở trong bytecode để tìm ra giá trị `msg.value` cần sử dụng.\n\n## Cách khắc phục\n\nHạn chế việc sử dụng hợp ngữ và không cho phép người dùng có thể gán các giá trị tùy ý cho các biến có kiểu là hàm.\n# Denial of Service with Block Gas Limit\n\n## Mô tả\n\nMỗi block trong Ethereum sẽ có một giới hạn gas nhất định #footnote[Tại thời điểm tháng 5 năm 2024 thì giới hạn này là 30 triệu gas @a2023_gas-and-fees.] Lỗ hổng này xảy ra khi lượng gas mà smart contract tiêu thụ vượt quá giới hạn gas của block.\n\nCác thao tác tiêu thụ nhiều gas chẳng hạn như chỉnh sửa mảng có kích thước tăng theo thời gian có thể gây ra từ chối dịch vụ.\n\n## Cách khắc phục\n\nThay vì chỉnh sửa mảng trong một block, có thể chia việc chỉnh sửa này ra nhiều block. Tổng quát hơn, cần xem xét lượng gas sử dụng trong smart contract một cách cẩn thận.\n# Typographical Error\n\n## Mô tả\n\nLỗi đánh máy có thể dẫn đến những hành vi không mong muốn trong smart contract. \n\nVí dụ:\n\n```solidity\npragma solidity ^0.4.25;\n\ncontract TypoOneCommand {\n  uint numberOne = 1;\n\n  function alwaysOne() public {\n    numberOne =+ 1;\n  }\n}\n```\n\nCó thể thấy, phép toán `numberOne += 1` được viết nhầm thành `numberOne =+ 1`. Biểu thức này có ý nghĩa là gán `numberOne` cho giá trị `+1` thay vì cộng `numberOne` cho 1.\n\n## Cách khắc phục\n\nLỗi này có thể được tránh khỏi nếu kiểm tra các điều kiện cần thiết trước khi thực hiện tính toán hoặc dùng thư viện SafeMath của OpenZeppelin.\n\nNgoài ra, toán tử một ngôi `+` đã bị loại bỏ kể từ phiên bản 0.5.0 @solidity-v0.5.0-breaking-changes của Solidity.\n# Right-To-Left Override Control Character\n\n## Mô tả\n\nKẻ xấu có thể sử dụng ký tự ghi đè phải sang trái (right-to-left override) có điểm mã (code point) là U+202E để thay đổi chiều hiển thị của các ký tự. \n\nKý tự này thường được dùng để che giấu phần mở rộng thực sự của tập tin nhằm đánh lừa người dùng. Ví dụ, khi sử dụng nó trong chuỗi `my-text.'U+202E'cod.exe` thì giá trị được hiển thị sẽ là `my-text.exe.doc` @u202e.\n\nỞ trong mã nguồn, ký tự U+202E có thể được sử dụng để thay đổi thứ tự của các đối số:\n\n```solidity\n/*\n * @source: https://youtu.be/P_Mtd5Fc_3E\n * @author: Shahar Zini\n */\npragma solidity ^0.5.0;\n\ncontract GuessTheNumber {\n  \n  // ...\n  \n  function guess(uint n) payable public {\n    require(msg.value == 1 ether);\n\n    uint p = address(this).balance;\n    checkAndTransferPrize(/*The prize‮/*rebmun desseug*/n , p/*‭\n            /*The user who should benefit */,msg.sender);\n  }\n  \n  // ...\n}\n```\n\nTrong ví dụ trên, thoạt nhìn thì có vẻ như biến `p` là đối số đầu tiên còn biến `n` là đối số thứ hai của hàm `checkAndTransferPrize`. Tuy nhiên, do tác dụng của ký tự U+202E, thứ tự thực sự của hai đối số này đã bị đảo ngược\n\nThứ tự gốc của chúng là:\n\n#figure(\n  image(\"/ethereum/imgs/Right-To-Left-Override.png\"),\n  caption: [Sử dụng ký tự U+202E để thay đổi thứ tự hiển thị của các đối số],\n)\n\nVới U+202D là ký tự ghi đè trái sang phải, được dùng để khôi phục chiều hiển thị.\n\n## Cách khắc phục\n\nCần loại bỏ ký tự ghi đè phải sang trái trong mã nguồn.\n# Unexpected Balance\n\n## Mô tả\n\nNgoài việc nhận ETH từ các hàm `payable`, smart contract còn có thể nhận ETH thông qua một số cách khác chẳng hạn như hàm `selfdestruct`.\n\nViệc giả định rằng ETH chỉ đến từ các hàm `payable` và thực hiện các phép so sánh đối với biến `this.balance` có thể làm ảnh hưởng đến kết quả thực thi của smart contract. Trong trường hợp xấu nhất, điều này có thể làm smart contract rơi vào trạng thái từ chối dịch vụ.\n\nVí dụ sau đây @self-destruct-ref là một trò chơi cho phép các người chơi đặt ETH vào smart contract thông qua hàm `deposit`. \n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract EtherGame {\n  \n  uint256 public targetAmount = 7 ether;\n  address public winner;\n\n  function deposit() public payable {\n    require(msg.value == 1 ether, \"You can only send 1 Ether\");\n\n    uint256 balance = address(this).balance;\n    require(balance <= targetAmount, \"Game is over\");\n\n    if (balance == targetAmount) {\n      winner = msg.sender;\n    }\n  }\n\n  function claimReward() public {\n    // ...\n  }\n    \n}\n```\n\nCó thể thấy, mỗi người chơi chỉ có thể đặt 1 ETH một lần và nếu người chơi nào làm cho số dư của smart contract chạm mốc 7 ETH thì sẽ trở thành người chiến thắng.\n\nKẻ tấn công có thể xây dựng một smart contract như sau:\n\n```solidity\ncontract Attacker {\n  \n  EtherGame etherGame;\n\n  constructor(EtherGame _etherGame) {\n    etherGame = EtherGame(_etherGame);\n  }\n\n  function attack() public payable {\n    address payable addr = payable(address(etherGame));\n    selfdestruct(addr);\n  }\n  \n}\n```\n\nHàm `attack` trong smart contract `Attacker` sẽ xóa bytecode của smart contract này trên blockchain rồi ép smart contract `EtherGame` nhận ETH thông qua hàm `selfdestruct`. \n\nGiả sử người chơi A đặt vào trò chơi 1 ETH, kẻ tấn công khởi tạo smart contract `Attacker` với `msg.value` là 7. Sau đó, kẻ tấn công gọi hàm `attack` để hủy bytecode của `Attacker` và chuyển 7 ETH sang cho `EtherGame`. Điều này khiến cho số dư (`this.balance`) của `EtherGame` có giá trị là 8 và khiến cho những người dùng khác không thể đặt cọc cũng như là trờ thành người chiến thắng (từ chối dịch vụ).\n\nCòn một cách khác để ép smart contract nhận ETH mà không thông qua việc gọi hàm. Cụ thể, kẻ tấn công xác định các địa chỉ smart contract mà một địa chỉ có thể tạo ra. Khi đó, kẻ tấn công sẽ gửi trước ETH vào các địa chỉ này và làm cho số dư của smart contract được tạo ra có giá trị khác 0.\n\nCông thức dùng để tính toán địa chỉ của smart contract:\n\n```solidity\nkeccak256(rlp.encode([<account_address>, <transaction_nonce>]))\n```\n\nVới:\n- `keccak256` là một hàm băm.\n- `rlp.encode` là minh họa cho việc encode dữ liệu theo giao thức RLP (Recursive-Length Prefix).\n- `account_address` là địa chỉ tạo ra smart contract.\n- `transanction_nonce` có giá trị bắt đầu bằng 1 và tăng dần theo thời gian khi có một giao dịch được gửi đi từ địa chỉ.\n\n## Cách khắc phục\n\nKhông sử dụng giá trị `this.balance` làm điều kiện để thực thi những hành động quan trọng. Thay vào đó, có thể sử dụng một biến để đếm lượng ETH được chuyển đến smart contract thông qua các hàm `payable`.\n\nVí dụ, đối với smart contract `EtherGame` trên, có thể dùng thêm biến `depositedEther` như sau:\n\n```solidity\ncontract EtherGame {\n  \n  uint256 public targetAmount = 7 ether;\n  address public winner;\n  uint public depositedEther;\n\n  function deposit() public payable {\n    require(msg.value == 1 ether, \"You can only send 1 Ether\");\n\n    uint balance = depositedEther + msg.value;\n    require(balance <= targetAmount, \"Game is over\");\n\n    if (balance == targetAmount) {\n      winner = msg.sender;\n    }\n\n    depositedEther += msg.value;\n  }\n\n  function claimReward() public {\n    // ...\n  }\n    \n}\n```\n# Hash Collisions with Multiple Variable Length Arguments\n\n## Hàm `abi.encodePacked`\n\nĐược dùng để đóng gói và ABI encode @abi-specification nhiều giá trị. Hàm này khác hàm `abi.encode` ở chỗ nó không thêm các số 0 vào giá trị đầu ra.\n\nGiả sử dùng hàm `abi.encodePacked` để encode các giá trị sau: \n- `int16(-1)`\n- `bytes1(0x42)`\n- `uint16(0x03)` \n- `string(\"Hello, world!\")`\n\nHàm này sẽ trả về giá trị `0xffff42000348656c6c6f2c20776f726c6421`, là sự kết hợp của các giá trị được encode:\n\n```txt\n0xffff42000348656c6c6f2c20776f726c6421\n  ^^^^                                 int16(-1)\n      ^^                               bytes1(0x42)\n        ^^^^                           uint16(0x03)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^ string(\"Hello, world!\") without a length field\n```\n\n## Mô tả\n\nViệc sử dụng hàm `abi.encodePacked` với đối số là các mảng có kích thước không cố định có thể gây ra đụng độ giá trị băm (hash collision). Lý do là vì hàm này đóng gói các phần tử mà không quan tâm đến việc chúng có thuộc một mảng nào đó hay không. Cụ thể, hai dòng sau đây sẽ cho ra kết quả tương đương:\n\n```solidity\nabi.encodePacked([addr1, addr2], [addr3, addr4]);\nabi.encodePacked([addr1, addr2, addr3], [addr4]);\n```\n\nNếu smart contract sử dụng giá trị của hàm `abi.encodePacked` để xác thực thì kẻ tấn công có thể vượt qua xác thực bằng cách di chuyển một hoặc nhiều phần tử từ mảng này sang mảng khác.\n\nVí dụ:\n\n```solidity\n/*\n * @author: Steve Marx\n * Modified by Kaden Zipfel\n */\npragma solidity ^0.5.0;\n\nimport \"./ECDSA.sol\";\n\ncontract AccessControl {\n  \n  using ECDSA for bytes32;\n  mapping(address => bool) isAdmin;\n  mapping(address => bool) isRegularUser;\n  // Add admins and regular users.\n  function addUsers(\n    address[] calldata admins,\n    address[] calldata regularUsers,\n    bytes calldata signature\n  )\n      external\n  {\n    if (!isAdmin[msg.sender]) {\n      // Allow calls to be relayed with an admin's signature.\n      bytes32 hash = keccak256(abi.encodePacked(admins, regularUsers));\n      address signer = hash.toEthSignedMessageHash().recover(signature);\n      require(isAdmin[signer], \"Only admins can add users.\");\n    }\n    for (uint256 i = 0; i < admins.length; i++) {\n      isAdmin[admins[i]] = true;\n    }\n    for (uint256 i = 0; i < regularUsers.length; i++) {\n      isRegularUser[regularUsers[i]] = true;\n    }\n  }\n    \n}\n```\n\nNgười dùng có thể được thêm vào smart contract thông qua hàm `addUsers` bằng cách truyền vào mảng các admin, mảng các người dùng thông thường cùng với chữ ký của admin:\n\n```solidity\naddUsers([addr1, addr2], [addr3, <attacker's address>, addr4], sig)\n```\n\nKẻ tấn công có thể gọi hàm `addUsers` như sau:\n\n```solidity\naddUser([addr1, addr2, addr3, <attacker's address>], [addr4], sig)\n```\n\nNhư đã biết, việc di chuyển `addr3` và `<attacker's address>` sang mảng đầu tiên không làm thay đổi giá trị trả về của hàm `abi.encodePacked`. Nhờ đó, kẻ tấn công có thể tạo ra được chữ ký hợp lệ và trở thành admin.\n\n## Cách khắc phục\n\nChỉ dùng hàm `abi.encodePacked` với đối số có kích thước cố định. \n\nTrong ví dụ của smart contract `AccessControl` trên, chỉ cho phép thêm vào $n$ ($n in N^*$) người dùng cố định đối với mỗi lần gọi hàm.\n\nVí dụ thêm 1 người dùng:\n\n```solidity\n/*\n * @author: Steve Marx\n * Modified by Kaden Zipfel\n */\npragma solidity ^0.5.0;\n\nimport \"./ECDSA.sol\";\n\ncontract AccessControl {\n  \n  using ECDSA for bytes32;\n  mapping(address => bool) isAdmin;\n  mapping(address => bool) isRegularUser;\n  // Add a single user, either an admin or regular user.\n  function addUser(\n    address user,\n    bool admin,\n    bytes calldata signature\n  )\n      external\n  {\n    if (!isAdmin[msg.sender]) {\n      // Allow calls to be relayed with an admin's signature.\n      bytes32 hash = keccak256(abi.encodePacked(user));\n      address signer = hash.toEthSignedMessageHash().recover(signature);\n      require(isAdmin[signer], \"Only admins can add users.\");\n    }\n    if (admin) {\n      isAdmin[user] = true;\n    } else {\n      isRegularUser[user] = true;\n    }\n  }\n\n}\n```\n\nVí dụ thêm 3 người dùng:\n\n```solidity\n/*\n * @author: Steve Marx\n * Modified by Kaden Zipfel\n */\npragma solidity ^0.5.0;\n\nimport \"./ECDSA.sol\";\n\ncontract AccessControl {\n  \n  using ECDSA for bytes32;\n  mapping(address => bool) isAdmin;\n  mapping(address => bool) isRegularUser;\n  // Add admins and regular users.\n  function addUsers(\n    // Use fixed length arrays.\n    address[3] calldata admins,\n    address[3] calldata regularUsers,\n    bytes calldata signature\n  )\n      external\n  {\n    if (!isAdmin[msg.sender]) {\n      // Allow calls to be relayed with an admin's signature.\n      bytes32 hash = keccak256(abi.encodePacked(admins, regularUsers));\n      address signer = hash.toEthSignedMessageHash().recover(signature);\n      require(isAdmin[signer], \"Only admins can add users.\");\n    }\n    for (uint256 i = 0; i < admins.length; i++) {\n      isAdmin[admins[i]] = true;\n    }\n    for (uint256 i = 0; i < regularUsers.length; i++) {\n      isRegularUser[regularUsers[i]] = true;\n    }\n  }\n    \n}\n```\n# Frozen Ether\n\n## Mô tả\n\nNếu mã nguồn có các hàm `payable` nhưng không có hàm rút ETH thì sẽ khiến cho ETH bị khóa ở trong hợp đồng thông minh @zaazaa_2023_unveiling.\n\nVí dụ:\n\n```solidity\n// source: https://github.com/crytic/slither/wiki/Detector-Documentation#contracts-that-lock-ether\n\npragma solidity 0.4.24;\n\ncontract Locked {\n  \n    function receive() payable public { }\n    \n}\n```\n\n## Cách khắc phục\n\nXóa `payable` hoặc thêm vào hàm rút ETH.\n# Call to the Unknown\n\n## Mô tả\n\nLỗ hổng này xảy ra khi hàm fallback của một smart contract được thực thi theo một cách không mong đợi khi smart contract gọi hàm với signature không tồn tại hoặc gửi ETH.\n\nKẻ tấn công có thể cài đặt mã độc ở trong hàm fallback chẳng hạn như gọi đệ quy để gây ra lỗ hổng re-entrancy (@re-entrancy) hoặc cố tình hoàn trả giao dịch để làm smart contract rơi vào trạng thái từ chối dịch vụ.\n\nVí dụ:\n\n```solidity\npragma solidity 0.6.12;\n\ncontract CallToTheUnknown {\n\n  function call(address _addr) {\n    (bool success, bytes memory data) = _addr.call{\n    \tvalue: msg.value,\n    \tgas: 5000\n    }(abi.encodeWithSignature(\"foo(string,uint256)\", \"call foo\", 123));\n  }\n  \n}\n```\n\nNếu smart contract ở địa chỉ `_addr` không có hàm với signature là `\"foo(string,uint256)\"` thì hàm fallback của nó sẽ được gọi. \n\nViệc gọi hàm thông qua thực thể của smart contract cũng xảy ra vấn đề tương tự nếu giao diện của smart contract được định nghĩa trong mã nguồn không khớp với smart contract đã được triển khai trên blockchain.\n\nVí dụ:\n\n```solidity\ncontract Alice {\n  \n    function ping(uint) returns (uint256);\n    \n}\n\ncontract Bob {\n  \n    function pong(Alice a) {\n        a.ping(42);\n    }\n    \n}\n```\n\nTrong ví dụ trên, nếu signature của hàm `ping` không được khai báo đúng (chẳng hạn như sai kiểu dữ liệu của tham số) thì có thể dẫn đến việc thực thi hàm fallback một cách không mong muốn.\n\nCác hàm chuyển ETH chẳng hạn như `send` hoặc `transfer` cũng có thể gọi hàm `receive` hoặc `fallback` (là `function()` đối với các phiên bản trước 0.6.0) của smart contract nhận ETH trong một số trường hợp.\n\n## Cách khắc phục <call-to-the-unknown-remediation>\n\nCẩn trọng khi gọi đến các smart contract bên ngoài, đặc biệt là các smart contract được đánh dấu là không an toàn. Có thể triển khai mẫu thiết kế Check-Effect-Pattern như đã được đề cập trong @re-entrancy-remediation.\n# Hiding Malicious Code with External Contract\n\n## Mô tả\n\nTrong Solidity, bất kỳ địa chỉ nào cũng có thể được ép kiểu thành một thực thể của hợp đồng thông minh. Kẻ tấn công có thể lợi dụng điều này để giấu mã độc @hiding-malicious-code-with-external-contract-ref.\n\nTrong ví dụ dưới, kẻ tấn công triển khai `Foo` ở trên chuỗi khối với đối số hàm tạo là địa chỉ của `Mal`. Trong hàm tạo, `Foo` ép kiểu đối số thành một thực thể của `Bar`.\n\n```solidity\n// source: https://solidity-by-example.org/hacks/hiding-malicious-code-with-external-contract/\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\ncontract Foo {\n    Bar bar;\n\n    constructor(address _bar) {\n        bar = Bar(_bar);\n    }\n\n    function callBar() public {\n        bar.log();\n    }\n}\n\ncontract Bar {\n    event Log(string message);\n\n    function log() public {\n        emit Log(\"Bar was called\");\n    }\n}\n\ncontract Mal {\n    event Log(string message);\n\n    function log() public {\n        emit Log(\"Mal was called\");\n    }\n}\n```\n\nGiả sử người dùng chỉ đọc được mã nguồn của `Foo` và `Bar`, họ thấy rằng hai hợp đồng thông minh này không có vấn đề gì và gọi sử dụng hàm `Foo.callBar()`. Người dùng mong muốn hàm `Bar.log()` được gọi nhưng trên thực tế thì `Mal.log()` mới là hàm được gọi.\n\nKẻ tấn công cũng có thể sử dụng hàm fallback để chứa mã độc.\n\n## Cách khắc phục\n\nCó thể sử dụng những cách sau:\n- Khởi tạo một thực thể mới của hợp đồng thông minh ở trong hàm tạo.\n- Sử dụng trạng thái hiển thị của biến thực thể là `public` để người dùng có thể kiểm tra mã nguồn của hợp đồng thông minh trước khi thực thi hàm.\n\nMinh họa:\n\n```solidity\ncontract Foo {\n  Bar public bar;\n  // ...\n  constructor() public {\n      bar = new Bar();\n  }\n  // ...\n}\n```\n# Double Constructor\n\n## Mô tả\n\nTại phiên bản 0.4.22, smart contract có thể sử dụng cùng lúc hai loại hàm tạo: hàm tạo trùng tên với smart contract và hàm tạo có tên là `constructor`. Hàm tạo nào được định nghĩa trước sẽ được thực thi.\n\nVí dụ:\n\n```solidity\ncontract Example {\n\n  address public admin;\n\n  function Example() public {\n    admin = address(0x0);\n  }\n\n  constructor() public {\n    admin = msg.sender;\n  }\n  \n}\n```\n\nViệc dùng hai hàm tạo có thể khiến cho smart contract hoạt động không như mong đợi của lập trình viên.\n\n## Cách khắc phục\n\nChỉ sử dụng một hàm tạo hoặc sử dụng các phiên bản Solidity sau 0.4.22.\n# Built-in Symbol Shadowing\n\n## Mô tả\n\nLỗ hổng này xảy ra khi lập trình viên dùng các định danh (identifier) có sẵn của Solidity để đặt tên cho biến, hàm, modifier hoặc sự kiện. Điều này có thể thay đổi hành vi mặc định của ngôn ngữ và gây ra các lỗi nghiệp vụ @zaazaa_2023_unveiling.\n\nVí dụ:\n\n```solidity\n// source: https://github.com/crytic/slither/wiki/Detector-Documentation#builtin-symbol-shadowing\npragma solidity ^0.4.24;\n\ncontract Bug {\n  \n    uint now; // Overshadows current time stamp.\n\n    function assert(bool condition) public {\n        // Overshadows built-in symbol for providing assertions.\n    }\n\n    function get_next_expiration(uint earlier_time) private returns (uint) {\n        return now + 259200; // References overshadowed timestamp.\n    }\n    \n}\n```\n\nTrong ví dụ trên, định danh `now` được đặt tên cho biến còn định danh `assert` được đặt tên cho hàm.\n\n## Cách khắc phục\n\nThay đổi tên của biến, hàm, modifier hoặc sự kiện mà trùng với tên định danh.\n# Identity Verification\n\n## Mô tả\n\nMột số smart contract kiểm tra xem một địa chỉ có phải là smart contract hay không thông qua opcode `extcodesize`.\n\n```solidity\ncontract OnlyForHuman {\n  \n  function isContract(address addr) returns (bool) {\n    uint size;\n    assembly { size := extcodesize(addr) }\n    return size > 0;\n  }\n  \n}\n```\n\nCụ thể, opcode này giúp trả về kích thước bytecode của địa chỉ ở trên blockchain. Việc kiểm tra này có thể đến từ nhu cầu chỉ cho phép các địa chỉ không phải là của smart contract thực thi hàm.\n\nTuy nhiên, kẻ tấn công có thể thực thi hàm ở trong hàm tạo và vượt qua được cách kiểm tra trên. Lý do là vì trong quá trình hàm tạo thực thi, giá trị trả về của `extcodesize` sẽ là 0.\n\nVí dụ @how-does-a-contract-find-out-if-another-address-is-a-contract:\n\n```solidity\npragma solidity 0.4.25;\n\ncontract Victim {\n\n  function isContract() public view returns(bool){\n    uint32 size;\n    address a = msg.sender;\n    assembly {\n      size := extcodesize(a)\n    }\n    return (size > 0);\n  }\n\n}\n\ncontract Attacker {\n    \n  bool public iTrickedIt;\n  Victim v;\n  \n  constructor(address _v) public {\n    v = Victim(_v);\n    // addrss(this) doesn't have code, yet\n    iTrickedIt = !v.isContract();\n  }\n}\n```\n\nTrong ví dụ trên, sau khi smart contract `Attacker` được triển khai ở trên blockchain, giá trị của `iTrickedIt` sẽ là `true` do giá trị trả về từ `v.isContract()` trong quá trình hàm tạo của `Attacker` đang thực thi là `false`.\n\n## Cách khắc phục\n\nĐể nhận biết một địa chỉ không phải là smart contract, có thể so sánh giá trị `tx.origin` với giá trị `msg.sender`.\n\n```solidity\ncontract OnlyForHuman {\n  \n  modifier isHuman() {\n    require(tx.origin == msg.sender, \"sorry humans only\");\n    _;\n  }\n  \n}\n```\n\nTuy nhiên, việc sử dụng `tx.origin` để xác thực có thể dẫn đến lỗ hổng Authorization through tx.origin ở @authorization-through-tx-origin.\n\n# Immutable Bugs \n\n## Mô tả\n\nSmart contract sau khi được triển khai lên mạng blockchain thì không thể được chỉnh sửa, kể cả khi có lỗi. Các lỗi này có thể bị khai thác bởi kẻ tấn công và thiệt hại gây ra là không thể khôi phục #footnote[The DAO là ngoại lệ duy nhất].\n\n## Cách khắc phục\n\nCó thể sử dụng các mẫu thiết kế giúp \"nâng cấp\" smart contract chẳng hạn như mẫu Proxy #footnote[@proxy-pattern[Phụ lục]] @transparent-proxy-pattern.\n\n# Ether Lost in Transfer\n\n## Mô tả\n\nETH được chuyển vào các địa chỉ mồ côi (không gắn liền với bất kỳ người dùng hoặc smart contract nào) sẽ bị mất hoàn toàn.\n\n## Cách khắc phục\n\nDo không có cách nào biết được một địa chỉ có phải là địa chỉ mồ côi hay không, lập trình viên cần đảm bảo tính đúng đắn của các địa chỉ nhận ETH ở trong smart contract một cách thủ công.\n# Stack Size Limit\n\n## Mô tả\n\nMỗi lần smart contract gọi thực thi hàm của  smart contract khác (hoặc gọi đến chính nó thông qua `this.f()`), call stack tương ứng với giao dịch sẽ tăng lên một frame @atzei_2017_a. Giới hạn của call stack cho mỗi giao dịch là 1024 @solidity-1024-call-stack-depth. Khi chạm đến giới hạn này, tất cả các lời gọi hàm đến bên ngoài smart contract (hoặc `this.f()`) đều gây ra ngoại lệ.\n\nKẻ tấn công có thể khai thác tính chất này để tạo ra một giao dịch có call stack gần đầy trước khi gọi hàm trong smart contract để gây ra ngoại lệ. Nếu ngoại lệ không được xử lý thì smart contract có thể rơi vào trạng thái từ chối dịch vụ.\n\nVí dụ, xét smart contract sau:\n\n```solidity\ncontract Government {\n\n  // ...\n  function lendGovernmentMoney() returns (bool) {\n    uint amount = msg.value;\n    if (lastTimeOfNewCredit + ONE_MINUTE < block.timestamp) {\n      // Return money to sender\n      msg.sender.send(amount);\n      // Sends all contract money to the last creditor\n      creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash);\n      corruptElite.send(this.balance);\n      // Reset contract state\n      lastTimeOfNewCredit = block.timestamp;\n      profitFromCrash = 0;\n      creditorAddresses = new address[](0);\n      creditorAmounts = new uint[](0);\n      round += 1;\n      return false;\n    }\n    // ...\n  }\n  // ...\n  \n}\n```\n\nKẻ tấn công có thể là chủ sở hữu smart contract và ý định của người này là không chuyển ETH cho người chiến thắng. Để khai thác lỗ hổng, kẻ tấn công xây dựng một smart contract như sau:\n\n```solidity\ncontract Attacker {\n  \n  function attack(address target, uint count) {\n    if (0 <= count && count < 1023) {\n      this.attack.gas(msg.gas - 2000)(target, count + 1);\n    } else {\n      Governmental(target).lendGovernmentMoney();\n    }\n  }\n  \n}\n```\n\nCó thể thấy, hàm `attack` của `Attacker` tự gọi đến chính nó 1022 lần. Sau đó, nó gọi đến hàm `lendGovernmentMoney` của `Governmental`. Độ sâu của call stack lúc này là 1023.\n\nKhi `lendGovernmentMoney` gọi hàm `send` lần đầu tiên (`msg.sender.send(amount)`), call stack sẽ có độ sâu là 1024. Điều này sẽ gây ra ngoại lệ và khiến giao dịch bị hoàn trả.\n\n## Cách khắc phục\n\nSau khi có EIP-150 @eip-150, smart contract gọi hàm chỉ cung cấp 63/64 lượng gas còn lại cho smart contract khác. \n\nCụ thể, lượng gas R được giữ lại ở smart contract gọi hàm sẽ là @eip-150-and-the-63-64-rule-for-gas:\n\n$\nR = A - 63/64 * A\n$\n\nVới $A$ là lượng gas khả dụng tối đa ở độ sâu $N$ của call stack (không tính lượng gas tiêu thụ bởi những thao tác khác trong hàm). Giá trị này được tính như sau:\n\n$\nA = I * (63/64)^N\n$\n\nVới I là lượng gas ban đầu (tại độ sâu 0 của call stack).\n\nVí dụ, gas ban đầu là 3000 thì:\n- Độ sâu $N = 10$ sẽ có $3000 * (63/64)^{10} = 2562$ gas khả dụng.\n- Độ sâu $N = 20$ sẽ có $3000 * (63/64)^{20} = 2189$ gas khả dụng.\n\n\n\n#figure(image(\"imgs/Gas available graph.png\"), caption: [Minh họa tỷ lệ gas khả dụng theo độ sâu của ngăn xếp])\n\nCó thể thấy, lượng gas khả dụng giảm rất nhanh xuống 0 và giúp tránh được việc call stack bị tràn.\n# Function Selector Clashing\n\n## Mô tả\n\nEVM sẽ dựa vào 4 byte đầu tiên trong dữ liệu của một giao dịch gọi hàm để thực thi hàm tương ứng. Tuy nhiên, 4 byte này dễ bị đụng độ giá trị băm và có thể dẫn đến việc smart contract thực thi một hàm nào đó mà người dùng không mong muốn.\n\nXét proxy contract ở @proxy-pattern[phụ lục] với logic contract có dạng như sau @a2019_beware-of-the-proxy-learn-how-to-exploit-function-clashing:\n\n```solidity\npragma solidity ^0.5.0;\n\nimport \"openzeppelin-eth/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"openzeppelin-eth/contracts/token/ERC20/ERC20Detailed.sol\";\nimport \"zos-lib/contracts/Initializable.sol\";\n\ncontract BurnableToken is Initializable, ERC20Burnable, ERC20Detailed {\n\n  function initialize(\n    string memory name,\n    string memory symbol,\n    uint8 decimals,\n    uint256 initialSupply\n  ) \n    public \n    initializer\n  {\n    super.initialize(name, symbol, decimals);\n    _mint(msg.sender, initialSupply);\n  }\n  \n}\n```\n\nSmart contract `ERC20Burnable` @openzeppelin-contracts-token-erc20-extensions-erc20-burnable.sol có hàm `burn` như sau:\n\n```solidity\nimport {ERC20} from \"../ERC20.sol\";\nimport {Context} from \"../../../utils/Context.sol\";\n\nabstract contract ERC20Burnable is Context, ERC20 {\n\n    // ...\n    function burn(uint256 value) public virtual {\n      _burn(_msgSender(), value);\n    }\n    // ...\n    \n}\n```\n\nKẻ tấn công có thể thiết lập một hàm backdoor giúp rút ETH của người dùng ở trong proxy contract như sau @a2019_beware-of-the-proxy-learn-how-to-exploit-function-clashing:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract Proxy {\n\n  address public proxyOwner;\n  address public implementation;\n\n  // ...\n  function collate_propagate_storage(bytes16) external {\n    implementation.delegatecall(abi.encodeWithSignature(\n        \"transfer(address,uint256)\", proxyOwner, 1000\n    ));\n  }\n    \n}\n```\n\nGiả sử có một người dùng sử dụng smart contract `Proxy` của kẻ tấn công để gọi hàm `burn` của `ERC20Burnable`. Khi người dùng gọi hàm `burn`, 4 byte đầu tiên trong giao dịch gọi hàm `burn` sẽ là `0x42966c68`. Tuy nhiên, 4 byte đầu tiên trong giá trị băm của hàm `collate_propagate_storage` cũng là `0x42966c68`. \n\nTheo nguyên tắc, EVM sẽ thực thi hàm có giá trị băm của signature khớp với 4 byte này ở trong proxy contract. Dẫn đến, hàm `collate_propagate_storage` sẽ được thực thi thay vì hàm fallback.\n\n## Cách khắc phục\n\nĐiều kiện của lỗ hổng là phải có sự tồn tại của proxy contract bởi vì trình biên dịch sẽ phát hiện ra hai hàm trong cùng một smart contract có 4 byte đầu trong giá trị băm trùng nhau.\n\nNgoài ra, có thể sử dụng một số công cụ phân tích chẳng hạn như Slither @slither-upgradeability để phát hiện lỗ hổng này.\n\nNgười dùng cũng nên xem xét mã nguồn của proxy contract một cách cẩn thận trước khi sử dụng.\n# Message Call with Hardcoded Gas Amount\n\n## Mô tả\n\nHàm `transfer` và hàm `send` đã từng được sử dụng để giải quyết lỗ hổng re-entrancy (@re-entrancy) vì chúng chỉ cung cấp cho smart contract nhận ETH 2300 gas (hoặc nhỏ hơn) #footnote[Dưới phiên bản 0.4.0 thì hàm `send` có gas là 0 nếu lượng ETH chuyển đi là 0 và gas là 2300 nếu lượng ETH chuyển đi khác 0.] - lượng gas này quá nhỏ để thực hiện các thao tác phức tạp chẳng hạn như cập nhật biến trạng thái hoặc gọi hàm.\n\nTuy nhiên, một số sự thay đổi trong EVM gây ra bởi các lần hard fork có thể làm thay đổi giá gas và làm cho các giả định của các smart contract đã được triển khai về một giá gas cố định không còn đúng. Ví dụ, EIP-1884 @eip-1884 đã tăng giá của một số opcode chẳng hạn như `SLOAD` và làm một số smart contract không còn hoạt động được nữa.\n\nViệc sử dụng hàm `call` với mức gas cố định cũng tương tự.\n\nVí dụ:\n\n```solidity\n/*\n * @author: Bernhard Mueller (ConsenSys / MythX)\n */\npragma solidity 0.6.4;\n\ninterface ICallable {\n  function callMe() external;\n}\n\ncontract HardcodedNotGood {\n\n  address payable _callable = 0xaAaAaAaaAaAaAaaAaAAAAAAAAaaaAaAaAaaAaaAa;\n  ICallable callable = ICallable(_callable);\n\n  constructor() public payable {\n  }\n\n  function doTransfer(uint256 amount) public {\n    _callable.transfer(amount);\n  }\n\n  function doSend(uint256 amount) public {\n    _callable.send(amount);\n  }\n\n   function callLowLevel() public {\n     _callable.call.value(0).gas(10000)(\"\");\n   }\n\n   function callWithArgs() public {\n     callable.callMe{gas: 10000}();\n   }\n   \n}\n```\n\n## Cách khắc phục\n\nKhông sử dụng `transfer` và `send` cũng như là chỉ định mức gas cố định khi sử dụng hàm `call`. Để tránh lỗ hổng re-entrancy khi sử dụng hàm `call`, có thể triển khai các mẫu bảo mật đã được đề cập ở @re-entrancy-remediation.\n# Short Address\n\n## Mô tả\n\nLỗ hổng này liên quan đến cách mà EVM decode dữ liệu giao dịch. Cụ thể hơn, nó liên quan đến việc hợp đồng thông minh sử dụng đối số có kiểu là địa chỉ (`address`) nhưng không thực hiện kiểm tra độ dài của dữ liệu giao dịch.\n\nXét ví dụ sau:\n\n```solidity\n//source: https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/\npragma solidity ^0.4.11;\n \ncontract MyToken {\n  \n  mapping (address => uint) balances;\n  \n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n  \n  function MyToken() {\n    balances[tx.origin] = 10000;\n  }\n  \n  function sendCoin(address to, uint amount) returns(bool sufficient) {\n    if (balances[msg.sender] < amount) return false;\n    balances[msg.sender] -= amount;\n    balances[to] += amount;\n    Transfer(msg.sender, to, amount);\n    return true;\n  }\n  \n  function getBalance(address addr) constant returns(uint) {\n    return balances[addr];\n  }\n  \n}\n```\n\nGiao dịch thực thi hàm `sendCoin()` có dạng như sau:\n\n```\n0x90b98a11\n00000000000000000000000062bec9abe373123b9b635b75608f94eb8644163e\n0000000000000000000000000000000000000000000000000000000000000002\n```\n\nVới:\n- `0x90b98a11` là định danh hàm.\n- `00000000000000000000000062bec9abe373123b9b635b75608f94eb8644163e` là đối số thứ nhất: địa chỉ của bên nhận token. \n- `0000000000000000000000000000000000000000000000000000000000000002` là đối số thứ hai: lượng token cần gửi.\n\nGiả sử ứng dụng sử dụng hợp đồng thông minh trên cố định lượng token chuyển đi là 2 và chỉ nhận dữ liệu đầu vào là địa chỉ của bên nhận token.\n\nKẻ tấn công có thể sử dụng một địa chỉ có kích thước là 19 byte. Dữ liệu giao dịch có dạng như sau #footnote[Ký tự xuống dòng là để cho dễ nhìn, dữ liệu giao dịch không có ký tự này.]:\n\n```\n0x90b98a11\n00000000000000000000000062bec9abe373123b9b635b75608f94eb86441600\n00000000000000000000000000000000000000000000000000000000000002  \n                                                              ^^\n                                                The missing byte\n```\n\nSự kiện `Transfer` được kích hoạt có các giá trị như sau:\n- `_from`: `0x58bad47711113aea5bc5de02bce6dd7aae55cce5`\n- `_ to`: `0x62bec9abe373123b9b635b75608f94eb86441600`\n- `_value`: `512`\n\nCó thể thấy, byte `00` đầu tiên của đối số thứ hai được xem như là byte cuối cùng của đối số thứ nhất. Điều này khiến cho đối số thứ hai bị mất một byte. EVM xử lý vấn đề này bằng cách đệm thêm một byte `00` vào bên phải của đối số thứ hai, khiến cho giá trị của nó từ `0x02` (2) thành `0x0200` (512).\n\nNhư vậy, kẻ tấn công đã tạo ra một giao dịch với lượng token được chuyển đi gấp 256 lần. \n\nViệc có một địa chỉ với byte cuối là `0x0` và hợp đồng thông minh có ít nhất 512 token là không quá khó xảy ra.\n\n## Cách khắc phục\n\nThực hiện kiểm tra kích thước của dữ liệu giao dịch.\n\nVí dụ:\n\n```solidity\n// source: https://www.reddit.com/r/ethereum/comments/63s917/comment/dfwmhc3/\ncontract NonPayloadAttackableToken {\n  \n  modifier onlyPayloadSize(uint size) {\n    assert(msg.data.length == size + 4);\n    _;\n  } \n  \n  function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) {\n    // do stuff\n  }\n  \n}\n```\n\nTrong ví dụ trên:\n- `msg.data` chứa dữ liệu giao dịch và thuộc tính `length` cho biết kích thước của dữ liệu giao dịch.\n- Giá trị 4 byte cộng thêm chính là kích thước của định danh hàm.\n\nKể từ phiên bản 0.5.0, lỗ hổng này đã được giải quyết. Cụ thể, khi dữ liệu giao dịch không đủ kích thước thì giao dịch sẽ bị hoàn trả @v0.5.0-soliditychangelogmd.\n# Transaction Ordering Dependency\n\nCác tên gọi khác: Race Condition, Front Running.\n\n## Mô tả\n\nMiner thường ưu tiên chọn những giao dịch có phí gas cao để cho vào các block. Điều này khiến cho thứ tự gửi lên của các giao dịch không giống với thứ tự thực thi của chúng. \n\nLỗ hổng này xảy ra khi kẻ tấn công (có thể là miner) theo dõi danh sách các giao dịch đang chờ được thực thi ở trong blockchain và phát hiện ra một giao dịch nào đó có lợi hoặc gây bất lợi cho kẻ tấn công. Bằng cách tạo ra một giao dịch có phí gas cao hơn, kẻ tấn công có thể thu lợi hoặc hủy bỏ sự bất lợi nhờ vào việc miner luôn chọn những giao dịch có phí gas cao để thực thi.\n\nVí dụ @manning_2018_sigpsoliditysecurityblog:\n\n```solidity\ncontract FindThisHash {\n  \n  bytes32 constant public hash = 0xb5b5b97fafd9855eec9b41f74dfb6c38f5951141f9a3ecd7f44d5479b630ee0a;\n\n  constructor() public payable {} // load with ether\n\n  function solve(string solution) public {\n    // If you can find the pre image of the hash, receive 1000 ether\n    require(hash == sha3(solution));\n    msg.sender.transfer(1000 ether);\n  }\n  \n}\n```\n\nTrong ví dụ trên, smart contract đưa ra một bài toán là tìm tiền ảnh cho giá trị băm `0xb5b5b97fafd9855eec9b41f74dfb6c38f5951141f9a3ecd7f44d5479b630ee0a` với phần thưởng là 1000 ETH.\n\nGiả sử có một người dùng nào đó tìm ra lời giải là `Ethereum!` và gọi hàm `solve` để nhận phần thưởng. Kẻ tấn công đang theo dõi danh sách các giao dịch sẽ kiểm tra tính đúng đắn của lời giải này và tạo ra một giao dịch có chứa lời giải với phí gas cao hơn giao dịch của nạn nhân.\n\nMiner sẽ thực thi giao dịch của kẻ tấn công trước do nó có phí gas cao và điều này khiến cho kẻ tấn công nhận được 1000 ETH từ smart contract.\n\n## Cách khắc phục\n\nCó thể thiết lập mức gas tối đa cho một giao dịch nhằm ngăn chặn việc người dùng sử dụng giao dịch với phí gas cao để có lợi thế hơn những người dùng khác. \n\nTuy nhiên, cách này không thể ngăn chặn được những kẻ tấn công là miner bởi vì họ có thể sắp xếp thứ tự của các giao dịch một cách tùy ý mà không quan tâm đến phí gas. Giải pháp cho vấn đề này là sử dụng mô hình commit-reveal được đề cập ở trong @weak-sources-of-randomness-from-chain-attributes-remediation. \n\nCụ thể, mỗi người chơi chỉ gửi lên giá trị băm của lời giải. Bằng cách này, miner không thể sắp xếp các giao dịch do không biết được lời giải thực sự bên trong các giao dịch. Sau khi giao dịch có chứa giá trị băm được đóng vào khối ở trên blockchain, người dùng có thể tiết lộ lời giải để smart contract so khớp với giá trị băm trước đó nhằm quyết định người chiến thắng. \n\nDẫu vậy, mô hình commit-reveal cũng không thể che giấu giá trị ETH được gửi cùng với giao dịch và giá trị này có thể là một phần của lời giải cho bài toán của smart contract. Trong trường hợp cần che giấu lượng ETH được gửi cùng giao dịch, có thể sử dụng kỹ thuật Submarine Sends @submarine-sends.\n# Timestamp Dependency <timestamp-dependency>\n\n## Mô tả\n\nSmart contract có thể sử dụng các thuộc tính của block chẳng hạn như `block.timestamp` hoặc `block.number` làm điều kiện để thực thi một hành động nào đó. Tuy nhiên, việc smart contract phụ thuộc vào các giá trị này là không an toàn:\n- Trong trường hợp của `block.timestamp`, miner có thể thay đổi nhãn thời gian#footnote[Tất nhiên là không được nhỏ hơn nhãn thời gian của block trước đó hoặc quá xa trong tương lai (không quá 900 giây - tương ứng với 15 phút @luu_2016_making).] của block nên giá trị của nó có thể không như lập trình viên smart contract mong đợi.\n- Trường hợp của `block.number` cũng tương tự, giá trị này có thể biến thiên nhanh hơn hoặc chậm đi tùy thuộc vào thời gian đào một block trong mạng blockchain. Mà thời gian đào một block không cố định và có thể thay đổi vì nhiều lý do chẳng hạn như blockchain tổ chức lại sau khi fork.\n\nVí dụ:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract TimedCrowdsale {\n\n  event Finished();\n  event notFinished();\n\n  // Sale should finish exactly at January 1, 2019\n  function isSaleFinished() private returns (bool) {\n    return block.timestamp >= 1546300800;\n  }\n\n  function run() public {\n    if (isSaleFinished()) {\n      emit Finished();\n    } else {\n      emit notFinished();\n    }\n  }\n\n}\n```\n\nSmart contract trên sử dụng điều kiện `block.timestamp >= 1546300800` để phát ra sự kiện `Finished`. Giả sử thời gian hiện tại là 1546300000 (cách thời điểm kết thúc 800 giây và nhỏ hơn giới hạn 900 giây của Ethereum). Kẻ tấn công có thể làm cho sự kiện `Finished` được phát ra sớm hơn bằng cách gán nhãn thời gian cho block là thời điểm kết thúc (1546300800).\n\n## Cách khắc phục\n\n- Lập trình viên cần chú ý đến tính khả biến của các thuộc tính liên quan đến block khi sử dụng trong smart contract.\n- Sử dụng Oracle #footnote[Là một loại công nghệ cho phép smart contract kết nối đến thế giới bên ngoài, thường là để lấy các số ngẫu nhiên hoặc dữ liệu thời gian thực] nếu có nhu cầu sinh số ngẫu nhiên (tương tự như phần @weak-sources-of-randomness-from-chain-attributes-remediation[]).\n  \n\n# Unencrypted Private Data On-Chain\n\n## Mô tả\n\nTrạng thái hiển thị `private` không đảm bảo rằng giá trị của biến sẽ được giữ bí mật. Bởi vì, khi cập nhật các biến trạng thái, người dùng cần gửi các giao dịch lên blockchain. Các giao dịch này là công khai với tất cả mọi người và có thể được phân tích bởi kẻ tấn công nhằm suy ra giá trị của biến. \n\nDo tính chất này, smart contract không nên lưu những dữ liệu riêng tư hoặc cần mã hóa.\n\nVí dụ, xét smart contract `OddEven` sau:\n\n```solidity\n/*\n * @source: https://gist.github.com/manojpramesh/336882804402bee8d6b99bea453caadd#file-odd-even-sol\n * @author: https://github.com/manojpramesh\n * Modified by Kaden Zipfel\n */\n\npragma solidity ^0.5.0;\n\ncontract OddEven {\n  \n  struct Player {\n    address addr;\n    uint number;\n  }\n\n  Player[2] private players;\n  uint count = 0;\n\n  function play(uint number) public payable {\n    require(msg.value == 1 ether, 'msg.value must be 1 eth');\n    players[count] = Player(msg.sender, number);\n    count++;\n    if (count == 2) selectWinner();\n  }\n\n  function selectWinner() private {\n    uint n = players[0].number + players[1].number;\n    (bool success, ) = players[n%2].addr.call.value(address(this).balance)(\"\");\n    require(success, 'transfer failed');\n    delete players;\n    count = 0;\n  }\n  \n}\n```\n\nSmart contract trên là một trò chơi giữa hai người chơi. Mỗi người chơi lần lượt gọi hàm `play` với đối số của `number` là một con số bất kỳ. Nếu tổng hai số của hai người chơi (`n`) là chẵn thì người chơi đầu tiên sẽ được nhận toàn bộ ETH của contract. Ngược lại, nếu `n` là lẻ thì người chơi thứ hai sẽ được nhận toàn bộ ETH.\n\nGiả sử người chơi đầu tiên gọi hàm `play` trong một giao dịch có dữ liệu như sau:\n\n```\n0x6587f6ec0000000000000000000000000000000000000000000000000000000000000064\n```\n\nNgười chơi thứ hai sẽ phân tích dữ liệu trên như sau @r_2018_keeping-secrets-on-ethereum:\n- `6587f6ec` là 4 byte đầu tiên trong giá trị băm Keccak-256 của \"play(uint)\".\n- `0000000000000000000000000000000000000000000000000000000000000064` là giá trị đối số của `number` được đệm cho đủ 32 byte và có giá trị ở hệ thập phân là 100.\n\nTừ những thông tin này, người chơi thứ hai sẽ chọn một số lẻ bất kỳ để tổng hai số của hai người chơi là số lẻ nhằm nhận được ETH từ smart contract.\n\n## Cách khắc phục\n\nLưu dữ liệu riêng tư ở bên ngoài blockchain hoặc sử dụng mã hóa. \n\nĐối với smart contracrt `OddEven` ở trên, có thể áp dụng mô hình commit-reveal tương tự như phần @weak-sources-of-randomness-from-chain-attributes-remediation[]. Cụ thể, các biến trạng thái và cấu trúc trong smart contract phục vụ cho trò chơi sẽ có dạng như sau:\n\n```solidity\n/*\n * @source: https://github.com/yahgwai/rps\n * @author: Chris Buckland\n * Modified by Kaden Zipfel\n * Modified by Kacper Żuk\n */\n\ncontract OddEven {\n  \n  enum Stage {\n    FirstCommit,\n    SecondCommit,\n    FirstReveal,\n    SecondReveal,\n    Distribution\n  }\n\n  struct Player {\n    address addr;\n    bytes32 commitment;\n    bool revealed;\n    uint number;\n  }\n\n  Player[2] private players;\n  Stage public stage = Stage.FirstCommit;\n  // ...\n  \n}\n```\n\nTrò chơi sẽ bao gồm 3 giai đoạn. Giai đoạn đầu tiên là giai đoạn commit:\n\n```solidity\ncontract OddEven {\n  \n  // ...\n  function play(bytes32 commitment) public payable {\n    // Only run during commit stages\n    uint playerIndex;\n    if(stage == Stage.FirstCommit) playerIndex = 0;\n    else if(stage == Stage.SecondCommit) playerIndex = 1;\n    else revert(\"only two players allowed\");\n\n    // Require proper amount deposited\n    // 1 ETH as a bet + 1 ETH as a bond\n    require(msg.value == 2 ether, 'msg.value must be 2 eth');\n\n    // Store the commitment\n    players[playerIndex] = Player(msg.sender, commitment, false, 0);\n\n    // Move to next stage\n    if(stage == Stage.FirstCommit) stage = Stage.SecondCommit;\n    else stage = Stage.FirstReveal;\n  }\n  // ...\n  \n}\n```\n\nỞ giai đoạn này, mỗi người chơi sẽ gửi lên smart contract giá trị băm (`commitment`) của các giá trị sau:\n- Địa chỉ của người chơi.\n- Con số tham gia trò chơi.\n- Một giá trị bí mật.\n\nNgoài ra, người chơi cũng cần phải gửi thêm 1 ETH nhằm đảm bảo người chơi sẽ phải tiết lộ con số tham gia trò chơi và giá trị bí mật.\n\nGiai đoạn thứ hai là giai đoạn tiết lộ bí mật:\n\n```solidity\ncontract OddEven {\n\n  // ...\n  function reveal(uint number, bytes32 blindingFactor) public {\n    // Only run during reveal stages\n    require(stage == Stage.FirstReveal || stage == Stage.SecondReveal, \"wrong stage\");\n\n    // Find the player index\n    uint playerIndex;\n    if(players[0].addr == msg.sender) playerIndex = 0;\n    else if(players[1].addr == msg.sender) playerIndex = 1;\n    else revert(\"unknown player\");\n\n    // Protect against double-reveal, which would trigger move to Stage.Distribution too early\n    require(!players[playerIndex].revealed, \"already revealed\");\n\n    // Check the hash to prove the player's honesty\n    require(keccak256(abi.encodePacked(msg.sender, number, blindingFactor)) == players[playerIndex].commitment, \"invalid hash\");\n\n    // Update player number if correct\n    players[playerIndex].number = number;\n\n    // Protect against double-reveal\n    players[playerIndex].revealed = true;\n\n    // Move to next stage\n    if(stage == Stage.FirstReveal) stage = Stage.SecondReveal;\n    else stage = Stage.Distribution;\n  }\n  // ...\n  \n}\n```\n\nỞ giai đoạn này, mỗi người chơi sẽ phải tiết lộ con số tham gia trò chơi (`number`) và giá trị bí mật (`blindingFactor`).\n\nGiai đoạn cuối cùng là giai đoạn tính toán kết quả và phân bố ETH:\n\n```solidity\ncontract OddEven {\n\n  // ...\n  function distribute() public {\n    // Only run during distribution stage\n    require(stage == Stage.Distribution, \"wrong stage\");\n\n    // Find winner\n    uint n = players[0].number + players[1].number;\n\n    // Payout winners winnings and bond\n    players[n%2].addr.call.value(3 ether)(\"\");\n\n    // Payback losers bond\n    players[(n+1)%2].addr.call.value(1 ether)(\"\");\n\n    // Reset the state\n    delete players;\n    stage = Stage.FirstCommit;\n  }\n  \n}\n```\n\nGiai đoạn này sẽ tính toán kết quả và gửi ETH cho các người chơi.\n# Untrustworthy Data Feeds\n\n## Mô tả\n\nĐể lấy dữ liệu từ bên ngoài blockchain, smart contract thường sử dụng các nguồn cấp dữ liệu chẳng hạn như các Oracle. Tuy nhiên, không có gì đảm bảo rằng dữ liệu từ các nguồn này là đáng tin cậy bởi vì kẻ tấn công có thể thao túng dữ liệu nhằm khiến cho các thao tác của smart contract trở nên sai lệch.\n\n## Cách khắc phục\n\nCó thể sử dụng công cụ Town Crier @town-crier. Công cụ này đóng vai trò như là một bên xác thực dữ liệu trung gian giữa smart contract và các nguồn cấp dữ liệu. \n\n\n"
}